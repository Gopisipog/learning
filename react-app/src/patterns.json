[
  {
    "title": "1. Two Pointers",
    "description": "Description\nThe Two Pointers technique is a clever strategy used in algorithm design, particularly when dealing with arrays or linked lists. Imagine you have two fingers, and you place each at different ends or positions of an array. These ‘fingers’ or pointers then traverse through the array, helping you to compare, search, or even manipulate the data efficiently.\n\nTwo Pointers\n\nUsage\nOrdered Data Structures: This pattern shines when applied to ordered arrays or lists, allowing for intelligent, position-based decisions that can significantly optimize the algorithm.\nEfficiency: By reducing the need for nested loops, the Two Pointers technique helps in achieving linear time complexity, making your algorithm faster and more efficient.\nPros and Cons\nPros:\nEfficiency: Achieves O(n) time complexity for problems that might otherwise require O(n^2).\nSimplicity: Once mastered, it provides a straightforward and elegant solution.\nCons:\nApplicability: Mainly beneficial for problems involving sequences or intervals.\nInitial Complexity: It might take some time to get the hang of this pattern and understand where and how to move the pointers.\nExample Problems from Grokking the Coding Interview\nPair with Target Sum: Find a pair in an array that adds up to a specific target sum.\nSquaring a Sorted Array: Given a sorted array, create a new array containing squares of all the numbers of the input array in the sorted order.\nTriplet Sum to Zero: Given an array of unsorted numbers, find all unique triplets in it that add up to zero."
  },
  {
    "title": "2. Island (Matrix Traversal) Pattern",
    "description": "Description\nThe Island pattern, also known as Matrix Traversal, is a technique used to navigate through a 2D array or matrix. The primary goal is to identify and process contiguous groups of elements, often referred to as ‘islands’. This pattern is particularly useful when you need to explore and manipulate grid-based data.\n\nIsland (Matrix Traversal) Pattern\n\nUsage\nGrid-Based Problems: Excelling in problems where you need to traverse a grid to find connected components or regions.\nContiguous Elements: Ideal for situations where you need to group together adjacent elements that share a common property.\nPros and Cons\nPros:\nComprehensive: Provides a thorough way to explore all the elements in a grid.\nVersatile: Can be used to solve a variety of problems related to 2D arrays.\nCons:\nComplexity: Can be more complex to implement compared to linear data structure traversal.\nSpace Overhead: May require additional space for recursion or queue/stack for breadth-first/depth-first traversal.\nExample Problems from Grokking the Coding Interview\nNumber of Islands: Count the number of islands in a given 2D matrix.\nBiggest Island: Find the largest island in terms of area or number of cells.\nFlood Fill: Change the color of an image represented by a 2D array."
  },
  {
    "title": "3. Fast & Slow Pointers",
    "description": "Description\nThe Fast & Slow Pointers technique involves two pointers traversing through a data structure at different speeds. This ingenious approach is particularly useful in identifying cycles, finding middle elements, and solving various other problems related to linked lists and arrays.\n\nFast & Slow Pointers\n\nUsage\nCycle Detection: Perfect for identifying cycles in a linked list or array, which is a common interview question.\nFinding Middle Elements: Efficiently find the middle element of a linked list without knowing the length beforehand.\nProblem-Specific Solutions: Solve specific problems like finding the start of a cycle in a linked list.\nPros and Cons\nPros:\nSpace Efficiency: Achieves solutions without the need for extra space, adhering to O(1) space complexity.\nVersatility: Applicable to a variety of problems, making it a versatile pattern to know.\nCons:\nInitial Complexity: Understanding how to move the pointers and at what speed can be tricky at first.\nSpecificity: While versatile, it is mostly beneficial for problems related to linked lists and certain array problems.\nExample Problems from Grokking the Coding Interview\nLinkedList Cycle: Determine if a linked list has a cycle.\nMiddle of the LinkedList: Find the middle node of a linked list.\nPalindrome LinkedList: Check if a linked list is a palindrome."
  },
  {
    "title": "4. Sliding Window",
    "description": "Description\nThe Sliding Window pattern involves creating a ‘window’ over a portion of data and sliding it across to solve problems efficiently. This technique is particularly useful for array or list-based problems where you need to find or calculate something among all the contiguous subarrays or sublists of a given size.\n\nSliding Window\n\nUsage\nContiguous Subarrays: Ideal for problems that require you to deal with contiguous subarrays or sublists.\nVariable Sized Window: Can be adapted for problems where the window size is not fixed and needs to be adjusted based on certain conditions.\nPros and Cons\nPros:\nEfficiency: Provides a way to reduce time complexity from O(n^2) to O(n) for specific problems.\nVersatility: Can be used for a variety of problems, including maximum sum subarray, smallest subarray with a given sum, and longest substring with K distinct characters.\nCons:\nInitial Complexity: Understanding how to adjust the window size and when to slide the window can be challenging initially.\nSpecificity: Mainly beneficial for problems involving contiguous subarrays or sublists.\nExample Problems from Grokking the Coding Interview\nMaximum Sum Subarray of Size K: Given an array of positive numbers and a positive number ‘k’, find the maximum sum of any contiguous subarray of size ‘k’.\nFruits Into Baskets: Given an array of characters where each character represents a fruit tree, you are given two baskets, and your goal is to put maximum number of fruits in each basket.\nLongest Substring with K Distinct Characters: Given a string, find the length of the longest substring in it with no more than K distinct characters."
  },
  {
    "title": "5. Merge Intervals",
    "description": "Description\nThe Merge Intervals pattern is a powerful technique used to deal with overlapping intervals or ranges. It involves sorting and then merging intervals based on specific conditions. This pattern is incredibly useful for time-based problems, scheduling, and range manipulation.\n\nUsage\nOverlapping Intervals: Perfect for problems where you need to merge overlapping intervals or find if an interval overlaps with any other.\nInterval Scheduling: Useful for problems that involve scheduling based on time intervals.\nPros and Cons\nPros:\nClarity: Provides a clear and systematic way to deal with overlapping intervals.\nEfficiency: Helps in reducing the problem complexity and achieving optimal solutions.\nCons:\nSorting Overhead: Requires the intervals to be sorted beforehand, which could add to the time complexity.\nSpecificity: Mainly beneficial for problems involving intervals and ranges.\nExample Problems from Grokking the Coding Interview\nMerge Intervals: Given a list of intervals, merge all the overlapping intervals to produce a list that has only mutually exclusive intervals.\nInsert Interval: Given a list of non-overlapping intervals sorted by their start time, insert a given interval at the correct position and merge all necessary intervals to produce a list that has only mutually exclusive intervals.\nIntervals Intersection: Given two lists of intervals, find the intersection of these two lists. Each list consists of disjoint intervals sorted on their start time."
  },
  {
    "title": "6. Cyclic Sort",
    "description": "Description\nCyclic Sort is a unique and intuitive sorting algorithm, particularly well-suited for problems where you are given a range of numbers and asked to sort them. The beauty of this pattern lies in its ability to sort the numbers in-place, utilizing the fact that the numbers are consecutive or have a specific range.\n\nUsage\nConsecutive Numbers: Ideal for scenarios where you have an array of numbers in a specific range, and you need to sort them or find missing/duplicate numbers.\nIn-Place Sorting: Provides a way to sort the numbers without using any extra space.\nPros and Cons\nPros:\nSpace Efficiency: Achieves sorting without the need for additional space, adhering to O(1) space complexity.\nTime Efficiency: Offers a linear time complexity solution for specific range-based sorting problems.\nCons:\nLimited Applicability: Best suited for problems involving numbers in a specific range and may not be applicable for other types of sorting problems.\nInitial Learning Curve: Understanding the cyclic sort pattern and knowing when to apply it can take some time.\nExample Problems from Grokking the Coding Interview\nFind the Missing Number: Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.\nFind all Duplicates: Find all the duplicate numbers (without using extra space and in O(n) runtime).\nDuplicates In Array: Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once."
  },
  {
    "title": "7. In-place Reversal of a Linked List",
    "description": "Description\nThe In-place Reversal of a Linked List pattern is a technique used to reverse the elements of a linked list without using additional memory. This is achieved by manipulating the pointers of the nodes in the linked list to reverse their direction.\n\nUsage\nMemory Efficiency: Since no additional data structures are used, this pattern is memory efficient.\nReversing Sub-lists: Can be extended to reverse sub-lists within a linked list, providing versatility in solving more complex problems.\nPros and Cons\nPros:\nSpace Efficiency: Achieves in-place reversal, ensuring O(1) space complexity.\nVersatility: Can be used to solve various problems related to linked lists, including reversing sub-lists and finding palindromes.\nCons:\nPointer Manipulation: Requires careful manipulation of pointers, which can be error-prone.\nInitial Learning Curve: Understanding how to reverse the pointers without losing the rest of the linked list can be challenging initially.\nExample Problems from Grokking the Coding Interview\nReverse a LinkedList: Given the head of a Singly LinkedList, reverse the LinkedList.\nReverse a Sub-list: Given the head of a LinkedList and two positions ‘p’ and ‘q’, reverse the LinkedList from position ‘p’ to ‘q’.\nReverse Every K-element Sub-list: Given the head of a LinkedList and a number ‘k’, reverse every ‘k’ sized sub-list starting from the head."
  },
  {
    "title": "8. Tree Breadth First Search",
    "description": "Description\nThe Tree Breadth First Search (BFS) pattern involves traversing a tree level by level, ensuring that you visit all the nodes at the current depth before moving on to the nodes at the next depth level. This is usually implemented using a queue.\n\nTree Breadth First Search\n\nUsage\nLevel Order Traversal: Ideal for problems that require you to traverse a tree in level order or when you need to perform operations on nodes at the same depth.\nMinimum Depth: Useful for finding the minimum depth of a tree, as you can stop the traversal once you find the first leaf node.\nPros and Cons\nPros:\nComplete Traversal: Ensures that every node in the tree is visited.\nLevel Order Information: Provides information about the depth or level of each node.\nCons:\nSpace Overhead: Requires additional space for the queue, which can be as large as the number of nodes at the largest level.\nNot as Efficient for Depth-Related Queries: For problems that depend on depth information, a depth-first search might be more efficient.\nExample Problems from Grokking the Coding Interview\nBinary Tree Level Order Traversal: Traverse a tree in level order and return the values of the nodes at each level.\nReverse Level Order Traversal: Traverse a tree in reverse level order.\nZigzag Traversal: Traverse a tree in a zigzag order."
  },
  {
    "title": "9. Tree Depth First Search",
    "description": "Description\nThe Tree Depth First Search (DFS) pattern involves traversing a tree in a depth-first manner, meaning you go as deep as possible down one branch before backing up and exploring other branches. This is typically implemented using recursion or a stack.\n\nUsage\nPath Finding: Ideal for problems where you need to find a path or check the existence of a path with certain properties.\nComplex Tree Traversals: Useful for more complex tree traversal problems where you need to maintain state or perform operations as you traverse.\nPros and Cons\nPros:\nSpace Efficiency: For a balanced tree, DFS uses less space than BFS.\nSimplicity: Recursive implementations can be more straightforward and concise.\nCons:\nCan Be Less Efficient for Wide Trees: For very wide trees, a DFS can use more space than BFS.\nMay Not Find the Shortest Path: If you're looking for the shortest path in an unweighted tree, BFS is generally a better choice.\nExample Problems from Grokking the Coding Interview\nBinary Tree Path Sum: Given a binary tree and a number ‘S’, find if the tree has a path from root-to-leaf such that the sum of all the node values of that path equals ‘S’.\nAll Paths for a Sum: Find all root-to-leaf paths in a binary tree that have a sum equal to a given number.\nCount Paths for a Sum: Find the number of paths in a tree that sum up to a given value."
  },
  {
    "title": "10. Two Heaps",
    "description": "Description\nThe Two Heaps pattern involves using two priority queues (heaps) to maintain a running balance or median of a set of numbers. One heap keeps track of the smaller half of the numbers, and the other keeps track of the larger half.\n\nUsage\nRunning Median: Perfect for problems where you need to find the median of a set of numbers as new numbers are added.\nBalanced Partition: Useful for problems where you need to maintain a balanced partition of numbers.\nPros and Cons\nPros:\nEfficiency: Provides a way to efficiently find the median or maintain balance in O(log N) time.\nDynamic: Can handle dynamic datasets where numbers are added over time.\nCons:\nComplexity: Implementation can be more complex due to the need to balance the two heaps.\nSpace Overhead: Requires additional space to store the numbers in the heaps.\nExample Problems from Grokking the Coding Interview\nFind the Median of a Number Stream: Design a class to calculate the median of a number stream.\nSliding Window Median: Find the median of all subarrays of size ‘K’ in the array.\nMaximize Capital: Given a set of investment projects with their respective profits, we need to find the most profitable projects. We are given an initial capital and are allowed to invest only in a fixed number of projects. Our goal is to choose projects that give us the maximum profit."
  },
  {
    "title": "11. Subsets",
    "description": "Description\nThe Subsets pattern involves dealing with problems that require generating all possible combinations or subsets of a set. This pattern is particularly useful when you need to explore all the different ways to combine elements, which is a common scenario in many coding problems.\n\nUsage\nCombinatorial Problems: Ideal for problems where you need to generate all possible combinations of elements.\nExhaustive Search: Useful when you need to perform an exhaustive search over all possible subsets of a set.\nPros and Cons\nPros:\nComprehensive: Ensures that you consider all possible combinations of elements.\nVersatile: Can be used to solve a variety of problems, including generating power sets, combinations, and permutations.\nCons:\nTime Complexity: Can lead to exponential time complexity, as the number of subsets of a set is 2^N.\nSpace Complexity: Requires additional space to store all the subsets.\nExample Problems from Grokking the Coding Interview\nSubsets: Given a set with distinct elements, find all of its distinct subsets.\nSubsets With Duplicates: Given a set of numbers that might contain duplicates, find all of its distinct subsets.\nPermutations: Given a set of distinct numbers, find all of its permutations."
  },
  {
    "title": "12. Modified Binary Search",
    "description": "Description\nThe Modified Binary Search pattern involves adapting the classic binary search algorithm to solve various problems, often related to searching in a sorted array or finding the boundary of a condition.\n\nUsage\nSorted Arrays: Perfect for problems involving searching or making decisions based on sorted arrays.\nFinding Boundaries: Useful for finding the start or end of a condition in a sorted array.\nPros and Cons\nPros:\nEfficiency: Provides a logarithmic time complexity solution for searching problems, making it highly efficient.\nVersatility: Can be adapted to solve a wide range of problems beyond simple searching.\nCons:\nApplicability: Mainly beneficial for problems involving sorted arrays or conditions with clear boundaries.\nImplementation Nuances: Requires careful implementation to handle edge cases and avoid infinite loops.\nExample Problems from Grokking the Coding Interview\nOrder-agnostic Binary Search: Given a sorted array of numbers, find the index of a given number. The array could be sorted in ascending or descending order.\nCeiling of a Number: Given an array of numbers sorted in ascending order, find the ceiling of a given number. The ceiling of a number is the smallest number in the given array greater than or equal to the given number.\nNext Letter: Given an array of lowercase letters sorted in ascending order, find the smallest letter in the given array greater than a given ‘key’."
  },
  {
    "title": "13. Bitwise XOR",
    "description": "Description\nThe Bitwise XOR pattern involves using the XOR bitwise operator to solve problems, often related to finding missing numbers or duplicate numbers in an array. XOR is a binary operator that returns 1 when the two bits are different and 0 when they are the same.\n\nUsage\nFinding Missing or Duplicate Numbers: Ideal for problems where you need to find a missing number or duplicate numbers in an array.\nBit Manipulation: Useful for problems that require manipulation of bits to achieve the desired result.\nPros and Cons\nPros:\nEfficiency: Provides a constant space solution for certain problems, making it highly efficient.\nSimplicity: Once understood, the XOR operator can be used to create elegant and simple solutions.\nCons:\nSpecificity: Mainly beneficial for problems involving finding missing or duplicate numbers.\nLearning Curve: Understanding how the XOR operator works and when to use it can take some time.\nExample Problems from Grokking the Coding Interview\nSingle Number: In a non-empty array of integers, every number appears twice except for one, find that single number.\nTwo Single Numbers: In a non-empty array of numbers, every number appears exactly twice except two numbers that appear only once. Find the two numbers that appear only once.\nComplement of Base 10 Number: For a given positive number N in base-10, return the complement of its binary representation as a base-10 integer."
  },
  {
    "title": "14. Top 'K' Elements",
    "description": "Description\nThe Top 'K' Elements pattern involves finding the 'K' largest or smallest elements in an array or stream of data. This pattern is particularly useful when dealing with large datasets and you need to maintain a subset of the data based on certain criteria.\n\nUsage\nPriority Queue: Utilizes a min-heap or max-heap to efficiently keep track of the 'K' largest or smallest elements.\nStreaming Data: Ideal for scenarios where the data is streaming in, and you need to maintain the 'K' largest or smallest elements at any given time.\nPros and Cons\nPros:\nEfficiency: Provides a way to find the 'K' largest or smallest elements in O(N log K) time.\nSpace Efficiency: Only requires O(K) space, regardless of the size of the dataset.\nCons:\nLimited to 'K' Elements: Only maintains information about the top 'K' elements, not the entire dataset.\nHeap Maintenance: Requires careful maintenance of the heap to ensure efficiency.\nExample Problems from Grokking the Coding Interview\nTop 'K' Numbers: Given an unsorted array of numbers, find the ‘K’ largest numbers in it.\nKth Smallest Number: Given an unsorted array of numbers, find the Kth smallest number in it.\n‘K’ Closest Points to the Origin: Given an array of points in the a 2D plane, find ‘K’ closest points to the origin."
  },
  {
    "title": "15. K-way Merge",
    "description": "Description\nThe K-way Merge pattern involves merging multiple sorted arrays or lists into a single sorted list. This pattern is highly useful in scenarios where you have multiple sorted datasets that you need to combine and maintain the sorted order.\n\nUsage\nMultiple Sorted Arrays: Ideal for merging multiple sorted arrays or lists.\nExternal Sorting: Useful in external sorting, where the data to be sorted does not fit into memory and is stored in sorted chunks.\nPros and Cons\nPros:\nEfficiency: Provides a way to merge multiple sorted arrays in O(N log K) time, where ‘N’ is the total number of elements across all arrays, and ‘K’ is the number of arrays.\nSpace Efficiency: Only requires O(K) space for the priority queue.\nCons:\nDependent on Sorting: The efficiency of this pattern depends on the arrays being sorted.\nPriority Queue Overhead: Requires maintenance of a priority queue, which adds to the complexity.\nExample Problems from Grokking the Coding Interview\nMerge K Sorted Lists: Given an array of ‘K’ sorted LinkedLists, merge them into one sorted list.\nKth Smallest Number in M Sorted Lists: Given ‘M’ sorted arrays, find the K’th smallest number among all the arrays.\nFind the Smallest Range Covering Elements from K Lists: Given ‘M’ sorted arrays, find the smallest range that includes at least one number from each of the ‘M’ lists."
  },
  {
    "title": "16. Topological Sort",
    "description": "Description\nTopological Sort is a pattern used for linearly ordering the vertices of a directed graph in such a way that for every directed edge (U, V), vertex U comes before V. This pattern is particularly useful in scenarios where you have a set of tasks and some tasks depend on others.\n\nUsage\nTask Scheduling: Ideal for problems where tasks need to be scheduled in a specific order, respecting their dependencies.\nCourse Scheduling: Useful in scenarios like course scheduling where some courses have prerequisites.\nPros and Cons\nPros:\nClarity: Provides a clear and systematic way to order tasks or vertices.\nDetecting Cycles: Helps in detecting cycles in a directed graph, which is important for understanding if a valid ordering is possible.\nCons:\nApplicability: Mainly beneficial for problems involving directed graphs and ordering of vertices.\nComplexity: Implementation can be complex, especially for beginners.\nExample Problems from Grokking the Coding Interview\nTopological Sort: Given a directed graph, find the topological ordering of its vertices.\nTasks Scheduling: Find if it is possible to schedule all the tasks.\nTasks Scheduling Order: Find the order of tasks we should pick to finish all tasks."
  },
  {
    "title": "17. Trie",
    "description": "Description\nA Trie, also known as a prefix tree, is a tree-like data structure used to store a dynamic set of strings, where the keys are usually strings. It is particularly useful for retrieval of a key in a dataset of strings, which makes it highly efficient for solving word-based problems.\n\nUsage\nAutocomplete: Ideal for implementing autocomplete functionality in search engines or text editors.\nSpell Checker: Useful for building spell checkers in word processors.\nIP Routing: Used in IP routing to store and search routes.\nPros and Cons\nPros:\nEfficiency: Provides fast retrieval of strings and is more efficient than hash tables or sets when it comes to string keys.\nPrefix Searching: Excellent for problems that require prefix searching or matching.\nCons:\nSpace Overhead: Can use more space compared to other data structures when the dataset is sparse.\nComplexity: Implementation can be complex, especially when handling deletion of words from the Trie.\nExample Problems from Grokking the Coding Interview\nInsert into and Search in a Trie: Implement insertion and search in a Trie.\nLongest Common Prefix: Find the longest common prefix of a set of strings.\nWord Search: Given a 2D board and a word, find if the word exists in the grid."
  },
  {
    "title": "18. Backtracking",
    "description": "Description\nBacktracking is a general algorithmic technique that considers searching through all the possible configurations of a search space in order to solve computational problems. It is particularly useful for optimization problems and when a complete search of the solution space is required. The main idea is to explore each possibility until the solution is found or all possibilities have been exhausted.\n\nUsage\nCombinatorial Problems: Ideal for solving problems that require generating all possible configurations like permutations, combinations, and subsets.\nPuzzle Solving: Useful for solving puzzles such as Sudoku, crossword puzzles, and the N-Queens problem.\nPros and Cons\nPros:\nCompleteness: Ensures that the entire solution space is explored, guaranteeing that the optimal solution will be found if it exists.\nSpace Efficiency: Uses less memory as it only needs to store the current state and the decision stack.\nCons:\nTime Complexity: Can lead to exponential time complexity, as it explores all possible configurations.\nOptimization Required: May require additional optimizations like pruning to be practical for larger instances.\nExample Problems from Grokking the Coding Interview\nSubsets: Given a set of numbers, find all of its subsets.\nPermutations: Given a set of distinct numbers, find all of its permutations.\nN-Queens: Place N queens on an N×N chessboard so that no two queens threaten each other."
  },
  {
    "title": "19. Monotonic Stack",
    "description": "Description\nA Monotonic Stack is a specialized data structure that maintains elements in a sorted order while supporting stack operations. It is particularly useful for problems where you need to find the next greater or smaller element in an array or when you need to maintain a running maximum or minimum value efficiently.\n\nUsage\nNext Greater Element: Ideal for finding the next greater element for each element in an array.\nMaximum Area Histogram: Useful for problems like finding the largest rectangular area under a histogram.\nPros and Cons\nPros:\nEfficiency: Provides a way to solve certain problems in linear time, making it highly efficient.\nSimplicity: Once understood, the monotonic stack can lead to concise and elegant solutions.\nCons:\nSpecificity: Mainly beneficial for problems involving finding the next greater or smaller element and related problems.\nLearning Curve: Understanding how and when to use a monotonic stack can take some time.\nExample Problems\nNext Greater Element: Given an array, find the next greater element for each element in the array.\nMaximum Area Histogram: Given a histogram, find the largest rectangular area under the histogram.\nLargest Rectangle in Histogram: Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram."
  },
  {
    "title": "20. 0/1 Knapsack (Dynamic Programming)",
    "description": "Description\nThe 0/1 Knapsack problem is a classic optimization problem that falls under the category of Dynamic Programming. In this problem, you are given a set of items, each with a weight and a value, and a knapsack with a maximum capacity. The goal is to determine the maximum value that can be accommodated in the knapsack without exceeding its capacity. The \"0/1\" part of the name reflects the fact that you can't break an item, you either take it or leave it.\n\nUsage\nResource Allocation: Ideal for problems where you need to optimally allocate limited resources to maximize profit or minimize cost.\nBudgeting: Useful for budgeting scenarios where you need to choose a subset of projects or investments to maximize return.\nPros and Cons\nPros:\nOptimality: Ensures that the optimal solution is found, provided that the problem satisfies the principle of optimality.\nGenerality: Can be adapted to solve a wide variety of optimization problems.\nCons:\nTime and Space Complexity: The naive implementation has a time and space complexity of O(nW), where n is the number of items and W is the capacity of the knapsack. This can be prohibitive for large inputs.\nRequires Integer Weights and Values: The classic 0/1 Knapsack problem requires weights and values to be integers.\nExample Problems from Grokking the Coding Interview\n0/1 Knapsack: Given the weights and profits of ‘N’ items, put these items in a knapsack which has a capacity ‘C’. The goal is to get the maximum profit out of the items in the knapsack.\nEqual Subset Sum Partition: Given a set of positive numbers, find if we can partition it into two subsets such that the sum of elements in both subsets is equal.\nSubset Sum: Given a set of positive numbers, determine if there exists a subset in the set whose sum is equal to a given number ‘S’."
  }
]