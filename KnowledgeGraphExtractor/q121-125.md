# Q121–Q125 — SQL Constraints, Keys, Triggers, Views (Beginner Learning Guide)
> Learning Guide
> - Audience: Beginners learning SQL and database fundamentals
> - Prerequisites: Basic SQL SELECT, INSERT, UPDATE, DELETE; table concepts
> - Objectives:
>   - Understand constraints and their role in data integrity
>   - Distinguish primary keys from unique keys
>   - Explain triggers, views, and WHERE vs HAVING
> - How to use: Read TL;DR, study examples, practice with a sample database


> - Objectives:
>   - Apply constraints for data quality and referential integrity
>   - Distinguish PK vs UNIQUE and their indexing implications
>   - Use triggers and views appropriately
>   - Correctly apply WHERE vs HAVING with GROUP BY
> - How to use: Skim TL;DR, practice the DDL samples, then complete the labs



---

## Q121 — Constraints

### TL;DR
Rules that enforce data integrity on columns/tables.

### Types
- PRIMARY KEY, UNIQUE, FOREIGN KEY, CHECK, DEFAULT, NOT NULL.

### Mini MCQ
Which constraint enforces referential integrity?
- A) CHECK
- B) FOREIGN KEY
- C) DEFAULT
Answer: B

---

## Q122 — Primary Key vs Unique Key

### TL;DR
PRIMARY KEY = unique + NOT NULL (one per table); UNIQUE = unique (nullable rules vary by RDBMS).

---

## Q123 — Triggers

### TL;DR
Procedural hooks that fire on DML (INSERT/UPDATE/DELETE).

### Types
- AFTER vs INSTEAD OF; row‑level vs statement‑level (varies by RDBMS).

---

## Q124 — Views

### TL;DR
Virtual table backed by a SELECT for abstraction/security/reuse.

---

## Q125 — WHERE vs HAVING

### TL;DR
WHERE filters rows before grouping; HAVING filters groups after GROUP BY.


---

## Scenario Prompts
- Design a table with constraints to enforce data integrity; show sample DDL.
- Migrate a table to add a new UNIQUE constraint safely on a large dataset.
- Use a trigger to audit sensitive updates; discuss pros/cons vs app-level auditing.
- Compare a view vs a stored query for security and abstraction needs.

## Quick Pseudocode Cheat‑Sheet
```pseudo
-- Constraints
---

## Hands‑on Labs
1) Create a sample database with constraints; test what happens when you violate them.
2) Build a view that joins multiple tables; query it and explain the abstraction benefits.
3) Write a trigger to log changes to a sensitive table; compare with application‑level auditing.

## Practice Checklist
- [ ] I can design tables with appropriate constraints
- [ ] I can explain primary key vs unique key differences
- [ ] I can write views for abstraction and security
- [ ] I can use WHERE vs HAVING correctly in GROUP BY queries

## Further Reading
- SQL constraint types and referential integrity
- Database normalization and design patterns
- Trigger best practices and alternatives

## Module Takeaways
- Constraints enforce data integrity at the database level
- Views provide abstraction and can improve security
- Understand when to filter before vs after grouping
CREATE TABLE Orders (
  OrderId INT PRIMARY KEY,
  CustomerId INT NOT NULL,
  Amount DECIMAL(10,2) CHECK (Amount >= 0),
  CONSTRAINT FK_Orders_Customers FOREIGN KEY (CustomerId) REFERENCES Customers(CustomerId)
);

-- View
---

## Hands‑on Labs
1) Create constraints on a new table and validate violations with sample data.
2) Add a UNIQUE constraint to an existing table using a filtered index; plan for duplicates.
3) Implement an audit trigger and compare to temporal tables/app‑level auditing.
4) Create a view and secure it for least‑privilege read access.

## Practice Checklist
- [ ] I can choose the right constraint for integrity needs
- [ ] I know PK vs UNIQUE behavior regarding NULLs by RDBMS
- [ ] I understand when to use triggers vs alternatives
- [ ] I can explain WHERE vs HAVING with examples

## Further Reading
- SQL Server documentation on constraints and indexes
- Triggers and temporal tables
- Views and security best practices

## Module Takeaways
- Constraints are your first line of defense for data quality
- Views and triggers are tools—use judiciously with security and maintainability in mind
- HAVING complements WHERE for grouped filters

CREATE VIEW v_CustomerOrders AS
SELECT c.Name, o.Amount FROM Customers c JOIN Orders o ON o.CustomerId = c.CustomerId;

-- WHERE vs HAVING
SELECT CustomerId, SUM(Amount) AS Total
FROM Orders
WHERE Amount > 0
GROUP BY CustomerId
HAVING SUM(Amount) > 1000;
```

