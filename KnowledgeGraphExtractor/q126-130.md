# Q126–Q130 — Advanced SQL: Subqueries, Identity Columns, and Joins (Expert Guide)

> Expert Learning Guide
> - Audience: Database architects, senior developers, and SQL performance specialists
> - Prerequisites: Advanced SQL knowledge, query optimization experience, database design principles
> - Objectives:
>   - Master complex subquery patterns and optimization strategies
>   - Understand identity column internals and sequence management
>   - Design optimal join strategies for complex data relationships
> - How to use: Study theoretical foundations, analyze performance implications, implement advanced patterns

---

## Q126 — Subqueries, Nested Queries, and Inner Queries

### Theoretical Foundation
Subqueries represent a fundamental concept in relational algebra, allowing for compositional query construction. They enable the decomposition of complex data retrieval problems into manageable, logical units while maintaining SQL's declarative nature.

### Advanced Patterns and Classifications

#### 1. Scalar Subqueries
```sql
-- Returns single value, can be used anywhere scalar expressions are allowed
SELECT emp_name, salary,
       (SELECT AVG(salary) FROM employees) as avg_salary,
       salary - (SELECT AVG(salary) FROM employees) as salary_diff
FROM employees
WHERE department_id = (SELECT dept_id FROM departments WHERE name = 'Engineering');
```

#### 2. Row Subqueries
```sql
-- Returns single row with multiple columns
SELECT * FROM employees 
WHERE (department_id, salary) = (
    SELECT department_id, MAX(salary) 
    FROM employees 
    GROUP BY department_id 
    HAVING department_id = 10
);
```

#### 3. Table Subqueries
```sql
-- Correlated subquery with EXISTS
SELECT e1.emp_name, e1.salary
FROM employees e1
WHERE EXISTS (
    SELECT 1 FROM employees e2 
    WHERE e2.department_id = e1.department_id 
    AND e2.salary > e1.salary
);
```

### Performance Optimization Strategies

#### Query Rewriting Techniques
```sql
-- Inefficient correlated subquery
SELECT emp_name FROM employees e1
WHERE salary > (SELECT AVG(salary) FROM employees e2 WHERE e2.dept_id = e1.dept_id);

-- Optimized with window functions
WITH dept_averages AS (
    SELECT emp_name, salary, dept_id,
           AVG(salary) OVER (PARTITION BY dept_id) as avg_dept_salary
    FROM employees
)
SELECT emp_name FROM dept_averages WHERE salary > avg_dept_salary;
```

### Edge Cases and Pitfalls
- **NULL handling**: Subqueries returning NULL can cause unexpected results
- **Cardinality violations**: Scalar subqueries returning multiple rows
- **Performance degradation**: N+1 query problems with correlated subqueries

---

## Q127 — Identity Columns and Auto-Increment Mechanisms

### Underlying Architecture
Identity columns in SQL Server utilize internal sequence generators with guaranteed uniqueness within table scope. The implementation involves:
- **Sequence cache management**: SQL Server pre-allocates identity values for performance
- **Transaction isolation**: Identity values are allocated outside transaction scope
- **Replication considerations**: Identity ranges for multi-master scenarios

### Advanced Identity Management

#### Custom Identity Patterns
```sql
-- Reseed identity after bulk operations
DBCC CHECKIDENT('employees', RESEED, 1000);

-- Identity with custom increment
CREATE TABLE orders (
    order_id INT IDENTITY(1000, 5) PRIMARY KEY,  -- Start: 1000, Increment: 5
    order_date DATETIME2 DEFAULT SYSDATETIME()
);

-- Computed identity for partitioned scenarios
CREATE TABLE partitioned_logs (
    log_id AS (CAST(partition_id AS VARCHAR(10)) + '_' + CAST(sequence_id AS VARCHAR(10))),
    partition_id INT NOT NULL,
    sequence_id INT IDENTITY(1,1),
    log_data NVARCHAR(MAX)
);
```

#### Identity in Distributed Systems
```sql
-- Multi-server identity strategy
-- Server 1: IDENTITY(1, 3) -> 1, 4, 7, 10...
-- Server 2: IDENTITY(2, 3) -> 2, 5, 8, 11...
-- Server 3: IDENTITY(3, 3) -> 3, 6, 9, 12...
```

### Modern Alternatives: Sequences
```sql
-- More flexible than IDENTITY
CREATE SEQUENCE order_seq
    START WITH 1000
    INCREMENT BY 1
    MINVALUE 1000
    MAXVALUE 999999999
    CYCLE
    CACHE 50;

-- Usage across multiple tables
INSERT INTO orders (order_id, customer_id) 
VALUES (NEXT VALUE FOR order_seq, @customer_id);

INSERT INTO order_audit (audit_id, order_id) 
VALUES (NEXT VALUE FOR order_seq, @order_id);
```

---

## Q128 — SQL Joins: Advanced Patterns and Optimization

### Join Algorithm Internals

#### Nested Loop Joins
- **Use case**: Small outer table, indexed inner table
- **Complexity**: O(n*m) worst case
- **Optimization**: Ensure proper indexing on join columns

#### Hash Joins
- **Use case**: Large tables without suitable indexes
- **Memory requirements**: Build phase requires sufficient memory
- **Spill considerations**: Performance degradation when hash table exceeds memory

#### Merge Joins
- **Use case**: Pre-sorted data or when sort is beneficial for other operations
- **Requirements**: Both inputs must be sorted on join keys

### Advanced Join Patterns

#### Lateral Joins (CROSS APPLY/OUTER APPLY)
```sql
-- Top N per group using CROSS APPLY
SELECT d.department_name, e.emp_name, e.salary
FROM departments d
CROSS APPLY (
    SELECT TOP 3 emp_name, salary
    FROM employees e
    WHERE e.department_id = d.department_id
    ORDER BY salary DESC
) e;

-- Function-based joins
SELECT c.customer_id, c.customer_name, s.total_sales
FROM customers c
OUTER APPLY dbo.GetCustomerSales(c.customer_id, @start_date, @end_date) s;
```

#### Conditional Joins
```sql
-- Multi-condition join with CASE
SELECT p.product_name, 
       CASE p.product_type
           WHEN 'DIGITAL' THEN d.download_url
           WHEN 'PHYSICAL' THEN s.shipping_address
       END as delivery_info
FROM products p
LEFT JOIN digital_products d ON p.product_id = d.product_id AND p.product_type = 'DIGITAL'
LEFT JOIN shipping_info s ON p.product_id = s.product_id AND p.product_type = 'PHYSICAL';
```

---

## Q129 — Join Types: Comprehensive Analysis

### Theoretical Foundation in Relational Algebra
- **Inner Join**: R ⋈ S (natural join)
- **Left Outer Join**: R ⟕ S
- **Right Outer Join**: R ⟖ S  
- **Full Outer Join**: R ⟗ S
- **Cross Join**: R × S (Cartesian product)

### Advanced Join Variations

#### Anti-Joins and Semi-Joins
```sql
-- Anti-join: Find customers with no orders
SELECT c.customer_id, c.customer_name
FROM customers c
WHERE NOT EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);

-- Semi-join: Find customers with at least one order
SELECT DISTINCT c.customer_id, c.customer_name
FROM customers c
WHERE EXISTS (SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id);
```

#### Inequality Joins
```sql
-- Range-based joins for time-series analysis
SELECT t1.timestamp, t1.value as current_value, t2.value as previous_value
FROM time_series t1
LEFT JOIN time_series t2 ON t2.timestamp < t1.timestamp 
    AND t2.timestamp = (
        SELECT MAX(timestamp) 
        FROM time_series t3 
        WHERE t3.timestamp < t1.timestamp
    );
```

---

## Q130 — Self-Joins: Hierarchical and Recursive Patterns

### Hierarchical Data Management

#### Employee-Manager Relationships
```sql
-- Multi-level hierarchy traversal
WITH management_hierarchy AS (
    -- Anchor: Top-level managers
    SELECT emp_id, emp_name, manager_id, 0 as level, 
           CAST(emp_name AS NVARCHAR(1000)) as hierarchy_path
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive: Subordinates
    SELECT e.emp_id, e.emp_name, e.manager_id, h.level + 1,
           CAST(h.hierarchy_path + ' -> ' + e.emp_name AS NVARCHAR(1000))
    FROM employees e
    INNER JOIN management_hierarchy h ON e.manager_id = h.emp_id
    WHERE h.level < 10  -- Prevent infinite recursion
)
SELECT * FROM management_hierarchy ORDER BY hierarchy_path;
```

#### Graph Traversal Patterns
```sql
-- Find all paths between nodes
WITH RECURSIVE path_finder AS (
    SELECT node_id, connected_node_id, 1 as path_length,
           CAST(node_id AS VARCHAR(1000)) + '->' + CAST(connected_node_id AS VARCHAR(1000)) as path
    FROM graph_edges
    WHERE node_id = @start_node
    
    UNION ALL
    
    SELECT pf.node_id, ge.connected_node_id, pf.path_length + 1,
           pf.path + '->' + CAST(ge.connected_node_id AS VARCHAR(1000))
    FROM path_finder pf
    JOIN graph_edges ge ON pf.connected_node_id = ge.node_id
    WHERE pf.path_length < @max_depth
    AND pf.path NOT LIKE '%' + CAST(ge.connected_node_id AS VARCHAR(10)) + '%'  -- Cycle detection
)
SELECT * FROM path_finder WHERE connected_node_id = @end_node;
```

### Performance Considerations for Self-Joins
- **Indexing strategy**: Composite indexes on (parent_id, child_id)
- **Materialized path**: Pre-computed hierarchy paths for read-heavy scenarios
- **Nested sets model**: Alternative to adjacency list for static hierarchies

---

## Hands-on Labs
1) Implement a complex reporting query using correlated subqueries, then optimize using window functions and measure performance differences
2) Design a multi-tenant identity strategy using sequences and implement collision detection
3) Build a recursive hierarchy traversal system with cycle detection and performance monitoring
4) Create a graph database simulation using self-joins with shortest path algorithms

## Advanced Scenarios
- Design subquery optimization strategies for data warehousing scenarios
- Implement distributed identity management across microservices
- Build complex join patterns for real-time analytics with streaming data
- Optimize hierarchical queries for large-scale organizational structures

## Performance Benchmarking
- Compare subquery vs JOIN vs EXISTS performance across different data volumes
- Analyze identity allocation patterns under high concurrency
- Measure join algorithm selection impact on query execution plans
- Evaluate recursive CTE performance vs iterative approaches

## Further Reading
- Query optimization internals and execution plan analysis
- Advanced indexing strategies for complex join patterns
- Distributed database identity management patterns
- Graph database concepts and SQL implementations
