# Q106–Q110 — Reflection, Serialization, Globalization, GC (Guide)
> Learning Guide
> - Audience: .NET engineers revising platform/runtime topics
> - Prerequisites: C# OOP, basics of JSON/XML, hosting/worker services, memory model
> - Objectives:
>   - Use Reflection safely and purposefully
>   - Choose the right serializer and plan for versioning
>   - Apply globalization/localization correctly
>   - Explain GC generations, LOH, and Dispose/finalization
> - How to use: Skim TL;DR, run the Example snippets, then attempt Scenario Prompts



---

## Q106 — Reflection

### TL;DR
Inspect metadata and interact with types/members at runtime; enables dynamic behaviors.

### Key Facts
- Namespaces: System.Reflection, System.Reflection.Emit.
- Common uses: DI/IoC, ORMs, serializers, plugin discovery, codegen.
- Costs: slower than static calls; security and versioning considerations.

### Example
```csharp
var t = Type.GetType("MyLib.Widget");
var obj = Activator.CreateInstance(t!);
var prop = t!.GetProperty("Name");
prop!.SetValue(obj, "Gopi");
```

### Pitfalls
- Brittle to renames; prefer expressions or Source Generators where possible.

### Mini MCQ
Which is true about Reflection?
- A) Always faster than direct calls
- B) Enables runtime type discovery
Answer: B

---

## Q107 — Serialization/Deserialization

### TL;DR
Convert objects to formats (JSON/XML/Binary) and back for storage/transport.

### Key Facts
- Prefer System.Text.Json; control with [JsonPropertyName], converters.
- Handle versioning with optional fields and defaults.

### Example
```csharp
var json = JsonSerializer.Serialize(order);
var back = JsonSerializer.Deserialize<Order>(json);
```

### Best Practices
- Avoid serializing secrets; validate inputs on deserialize.

### Mini MCQ
Which is recommended for modern .NET JSON?
- A) BinaryFormatter
- B) System.Text.Json
Answer: B

---

## Q108 — Globalization & Localization

### TL;DR
Globalization designs for many cultures; localization adapts to one via resources.

### Example
```csharp
Thread.CurrentThread.CurrentCulture = new CultureInfo("fr-FR");
```

### Best Practices
- Use resx resources; avoid hard‑coded strings; handle RTL/formatting.

### Mini MCQ
Localization is the process of…
- A) Designing for any culture
- B) Adapting to a specific culture
Answer: B

---

## Q109 — Windows/Worker Services

### TL;DR
Long‑running background processes managed by SCM or hosted as Worker Service.

### Key Facts
- Use Microsoft.Extensions.Hosting with IHostedService/BackgroundService.

### Example
```csharp
Host.CreateDefaultBuilder(args)
  .ConfigureServices(s => s.AddHostedService<Worker>())
  .Build().Run();
```

---

## Q110 — Garbage Collection

### TL;DR
Automatic memory management with generational, server/workstation modes.

### Key Facts
- Gen0/Gen1/Gen2, LOH; background and ephemeral collections.
- Finalization queue; IDisposable for unmanaged resources.

### Mini MCQ
Which heap is for large objects in .NET?
- A) SOH
- B) LOH
Answer: B

---

## Hands‑on Labs
1) Implement attribute-based plugin discovery and activation with Reflection.
2) Serialize/deserialize a polymorphic type using System.Text.Json with custom converters.
3) Localize a page to two cultures, including date/number formats and RTL.
4) Write a Worker Service with graceful shutdown and logging.

## Practice Checklist
- [ ] I can reflect types/members and understand the performance tradeoffs
- [ ] I can choose a serializer and design for version tolerance
- [ ] I can set culture and use resources correctly
- [ ] I can explain LOH and the Dispose/finalizer relationship

## Further Reading
- .NET docs: Reflection, Source Generators
- System.Text.Json guide and converters
- Globalization and localization in .NET
- Worker Service hosting in .NET

## Module Takeaways
- Reflection is powerful but slower; prefer compile-time when possible
- Plan serialization versioning; avoid BinaryFormatter
- Globalize by design; localize via resources and culture settings
- Understand GC generations and apply the Dispose pattern consistently


## Scenario Prompts
- Build a plugin discovery that loads assemblies, finds types with a custom attribute, and instantiates them.
- Migrate Newtonsoft.Json to System.Text.Json; outline compatibility and converter strategy.
- Localize an app for fr-FR and ar-SA; list formatting changes and RTL considerations.
- Design a Windows/Worker service with graceful shutdown and health checks.
- Investigate high Gen2 GCs and LOH fragmentation; propose fixes.

## Quick Pseudocode Cheat‑Sheet
```pseudo
// Reflection: attribute-based discovery
for asm in loadedAssemblies:
  for type in asm.Types:
    if type.HasAttribute(Plugin):
      plugins.add(Activator.CreateInstance(type))

// System.Text.Json usage
json = Serialize(obj)
obj2 = Deserialize<T>(json)

// Worker service
host = CreateDefaultHost()
host.AddHostedService(Worker)
host.Run()

// GC hygiene
using resource = Acquire()
// Dispose at scope end
```


---

