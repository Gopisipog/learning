# Q111–Q115 — GC and Threading Essentials (Learning Guide)
> Learning Guide
> - Audience: Backend/Platform engineers optimizing reliability and performance
> - Prerequisites: C# exceptions/try‑catch‑finally, IDisposable pattern, threading basics
> - Objectives:
>   - Explain GC generations, LOH, and when collections occur
>   - Choose Dispose vs Finalize and implement patterns safely
>   - Distinguish process vs thread and synchronization implications
> - How to use: Read TL;DR, study examples, attempt scenarios, then practice checklist



---

## Q111 — GC Generations

### TL;DR
Collect short‑lived objects frequently (Gen0/1) and long‑lived less often (Gen2) to optimize throughput.

### Key Facts
- LOH (Large Object Heap) is collected with Gen2; pinned objects fragment heaps.
- Background server GC for high‑throughput services.

### Mini MCQ
LOH collections happen with…
- A) Gen0
- B) Gen2
Answer: B

---

## Q112 — Dispose vs Finalize

### TL;DR
Dispose = deterministic, caller‑initiated; Finalize = non‑deterministic GC callback.

### Best Practices
- Implement IDisposable with SafeHandle; avoid finalizers unless absolutely necessary.
- Call GC.SuppressFinalize in Dispose if you have a finalizer.

### Example
```csharp
using var stream = File.OpenRead(path); // Dispose deterministically
```

---

## Q113 — Finalize vs Finally

- Finalize: object cleanup hook by GC.
- Finally: always‑run block in try/catch/finally.

---

## Q114 — Forcing GC

- GC.Collect() exists but is discouraged; rely on scope and Dispose.

---

## Q115 — Process vs Thread

### TL;DR
Process = isolated OS unit with memory; Thread = execution unit inside a process.

### Key Facts
- Threads share memory (need synchronization) and have lower creation cost than processes.


---

## Scenario Prompts
- Diagnose rising Gen2 collections; what patterns (finalizers, LOH allocations, pinning) could cause this?
- Refactor a class that owns a SafeHandle: show proper Dispose pattern and when to suppress finalization.
- Explain Finalize vs Finally in a code review where they’re being conflated.

## Quick Pseudocode Cheat‑Sheet
```pseudo
// IDisposable pattern (no finalizer)
class ResourceOwner implements IDisposable:
  disposed = false
  method Dispose():
    if disposed: return
    release managed/unmanaged
    disposed = true

// With finalizer
class NativeOwner implements IDisposable:
  ~NativeOwner(): Dispose(false)
  method Dispose(disposing=true):
    if disposing: dispose managed
    free unmanaged
    GC.SuppressFinalize(this)
```

## Hands‑on Labs
1) Instrument a sample app to allocate large arrays; observe LOH behavior and Gen2 collections.
2) Implement IDisposable with and without finalizer; measure impact using BenchmarkDotNet.
3) Build a small demo showing process vs thread characteristics (memory isolation, shared state).

## Practice Checklist
- [ ] I can explain Gen0/1/2 and LOH
- [ ] I can implement IDisposable and use SafeHandle appropriately
- [ ] I can justify not calling GC.Collect in normal code
- [ ] I can articulate process vs thread differences

## Further Reading


- .NET GC docs; Memory performance best practices
- IDisposable and SafeHandle patterns
- Threading in .NET; Synchronization primitives

## Module Takeaways
- Let the GC do its job; design for object lifetimes and disposal
- Prefer deterministic cleanup with IDisposable; finalizers only as safety nets
- Understand threading costs and synchronization for correctness


// With finalizer
class NativeOwner implements IDisposable:
  ~NativeOwner(): Dispose(false)
  method Dispose(disposing=true):
    if disposing: dispose managed
    free unmanaged
    GC.SuppressFinalize(this)
```

