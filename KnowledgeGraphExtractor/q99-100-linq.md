# Q99–Q100: LINQ Essentials

Full modules with definitions, examples, performance notes, MCQs, and scenarios.

---

## Q99. What is LINQ (Language Integrated Query)?
- Definition: A set of query operators embedded into C# (and .NET languages) providing a unified way to query data from in-memory collections (LINQ-to-Objects), databases (LINQ-to-SQL/EF), XML (LINQ-to-XML), etc.
- Benefits: Strong typing, IntelliSense, composability, readability, fewer stringly-typed queries.
- Example
```csharp
var products = new[]{
    new { Id=1, Price=12.5, Cat="A" },
    new { Id=2, Price=5.0,  Cat="B" },
    new { Id=3, Price=9.9,  Cat="A" }
};
var cheapA = products
    .Where(p => p.Cat == "A")
    .OrderBy(p => p.Price)
    .Select(p => p.Id)
    .ToList();
```
- Query syntax vs method syntax: Both compile to same; prefer method syntax in most modern code for clarity/composability.
- Deferred execution: Most operators are lazy; executed when enumerated (`ToList()`, `Count()`, `foreach`).

### Best Practices
- Keep queries pure (no side effects in selectors/predicates).
- Materialize (`ToList/ToArray`) only when needed; avoid multiple enumerations of expensive sources.
- For EF Core: Prefer server‑side evaluation; avoid client‑side fallback; inspect SQL with `ToQueryString()`.
- Use projections (`Select`) to fetch only needed columns.

### Pitfalls
- Hidden N+1 queries with ORMs; use `Include`, projections, or explicit loads.
- `Distinct`, `OrderBy` on large datasets can be costly; ensure indexed columns in DB.

### MCQ
- LINQ execution occurs … A) at declaration B) at enumeration C) at compile time — Answer: B.

---

## Q100. Advantages of LINQ
- Productivity: Concise, expressive, compile‑time checked queries.
- Maintainability: Consistent query style across providers.
- Safety: Strong types, fewer runtime SQL mistakes.
- Composability: Chain operators; reuse query parts with `IQueryable`/`IEnumerable`.
- Testability: LINQ-to-Objects enables unit testing of query logic.

### Example: Combining Filters
```csharp
IQueryable<User> ActiveInRegion(IQueryable<User> users,string region)
    => users.Where(u => u.Active && u.Region == region);

IQueryable<User> Paged(IQueryable<User> q,int page,int size)
    => q.OrderBy(u => u.Id).Skip((page-1)*size).Take(size);
```

### Performance Notes
- LINQ-to-Objects runs in-process; performance comparable to well‑written loops but with overhead per operator.
- For EF Core: Prefer async (`ToListAsync`), filtered projections, and SQL translation that hits indexes.
- Use `.AsNoTracking()` when entities are read-only.

### MCQs
1) LINQ enables… A) type safety B) provider-agnostic queries C) both — Answer: C.
2) EF Core translation target: A) client B) server SQL — Answer: B (prefer server evaluation).

### Scenario Prompts
- Refactor a nested loop filter into a LINQ pipeline and compare clarity/perf.
- Add logging to inspect the generated SQL for a complex EF Core query.

---

## Takeaways
- LINQ unifies querying across sources with strong typing and composability.
- Understand deferred execution, provider behavior, and performance trade-offs.

