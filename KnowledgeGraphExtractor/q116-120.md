# Q116–Q120 — Multithreading, Async/Await, and SQL Basics (Beginner Learning Guide)
> Learning Guide
> - Audience: Beginners learning concurrency and async in .NET
> - Prerequisites: C# basics, methods, exceptions; simple HTTP client usage
> - Objectives:
>   - Understand multithreading vs Tasks and when to use each
>   - Write non‑blocking async/await code and avoid deadlocks
>   - Explain DBMS vs RDBMS fundamentals
> - How to use: Read TL;DR and Key Facts, run Example snippets, then attempt Scenario Prompts and Labs


> - Objectives:
>   - Decide when to use threads vs tasks vs async I/O
>   - Avoid deadlocks and blocking in async code
>   - Apply synchronization primitives correctly
> - How to use: Review TL;DR + examples, then code the scenarios, and verify via the checklist



---

## Q116 — Multithreading

### TL;DR
Multiple threads within a process to improve responsiveness and throughput.

### Key Facts
- Primitives: Thread, ThreadPool; higher‑level: Task/TPL, async/await.
- Synchronization: lock/Monitor, Mutex, SemaphoreSlim, Concurrent collections.

### Example
```csharp
Parallel.ForEach(urls, url => Fetch(url));
```

---

## Q117 — Sync vs Async; Role of Task

### TL;DR
Sync blocks threads; async frees them. Task models ongoing operations and results.

### Best Practices
- Don’t block async code (.Result/Wait()).
- Use ConfigureAwait(false) in libraries.

### Example
```csharp
var data = await http.GetStringAsync(uri);
```

---

## Q118 — Threads vs Tasks

### TL;DR
Tasks provide scheduling, continuations, cancellation, and exception flow—simpler than raw threads.

### Example
```csharp
await Task.Run(() => CpuBound());
```

### Mini MCQ
Prefer Tasks over Threads mainly because…
- A) Tasks are always faster
- B) Tasks integrate with async/await and scheduling
Answer: B

---

## Q119 — Async/Await

### TL;DR
async enables await; await suspends until completion without blocking the thread.

### Pitfalls
- async void (except events), context deadlocks, forgotten CancellationTokens.

---

## Q120 — DBMS vs RDBMS

### TL;DR
RDBMS = relational model, SQL, ACID; DBMS is broader and may not enforce relations.


---

## Scenario Prompts
- Convert a synchronous I/O flow to async/await without blocking; identify deadlock risks.
- Choose between Task.Run and pure async I/O for a given workload; justify.

---

## Hands‑on Labs
1) Convert a synchronous file processing routine to async/await; ensure no blocking.
2) Build a small app that fetches 10 URLs concurrently with cancellation support.
3) Demonstrate a deadlock scenario with .Result and fix it.

## Practice Checklist
- [ ] I can choose between Task.Run and pure async I/O
- [ ] I can pass and honor CancellationToken
- [ ] I can explain deadlocks and context capture
- [ ] I can define DBMS vs RDBMS clearly

## Further Reading
- Async/Await best practices (.NET docs)
- TPL Dataflow (optional advanced)
- SQL: GROUP BY, HAVING, keys and constraints

## Module Takeaways
- Prefer pure async I/O; avoid blocking on Tasks
- Use proper synchronization primitives
- Understand SQL relational fundamentals for backend work

- Diagnose thread contention and propose sync primitive changes (e.g., to SemaphoreSlim).
- Explain when to use ValueTask and its caveats.

## Quick Pseudocode Cheat‑Sheet
```pseudo
// Async fetch with cancellation
async method FetchAll(urls, token):
  tasks = [ http.get(u, token) for u in urls ]
---

## Hands‑on Labs
1) Convert a blocking data access flow to async/await end‑to‑end (controller to DAL); validate no thread starvation.
2) Build a CPU‑bound pipeline off the UI thread with Task.Run and cancellation.
3) Replace a lock with SemaphoreSlim and compare throughput under contention.

## Practice Checklist
- [ ] I never block on async (.Result/Wait)
- [ ] I understand when to use Task.Run (CPU‑bound) vs async I/O (I/O‑bound)
- [ ] I can choose locks vs SemaphoreSlim vs concurrent collections appropriately
- [ ] I can use CancellationToken throughout call chains

## Further Reading
- Async/Await best practices (Stephen Cleary)
- TPL and Task-based asynchronous pattern
- Synchronization primitives in .NET

## Module Takeaways
- Prefer async I/O over threads for I/O-bound work
- Use Task.Run for CPU-bound segments to keep UIs/services responsive
- Choose synchronization carefully to avoid contention and deadlocks

  await Task.WhenAll(tasks)

// CPU-bound work off UI thread
result = await Task.Run(() => Compute(), token)

// Synchronization example
lock(obj):
  critical section
```

