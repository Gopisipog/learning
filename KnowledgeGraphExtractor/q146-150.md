# Q146–Q150 — ASP.NET MVC: Architecture, Lifecycle, and Advanced Patterns (Expert Guide)

> Expert Learning Guide
> - Audience: Senior .NET developers, solution architects, and MVC framework specialists
> - Prerequisites: Deep understanding of .NET Framework/Core, HTTP protocol, design patterns, and web application architecture
> - Objectives:
>   - Master MVC architectural patterns and request lifecycle optimization
>   - Implement advanced controller patterns and action result strategies
>   - Design sophisticated filter pipelines and cross-cutting concerns
>   - Build enterprise-grade authentication and authorization systems
> - How to use: Study architectural patterns, implement advanced scenarios, analyze performance implications

---

## Q146 — MVC Architecture and Request Lifecycle

### Theoretical Foundation: Model-View-Controller Pattern

The MVC pattern represents a fundamental architectural approach that separates application concerns into three interconnected components, enabling maintainable, testable, and scalable web applications. This separation of concerns facilitates parallel development, code reusability, and easier maintenance.

#### Advanced MVC Request Lifecycle Analysis

```csharp
// Custom HTTP Module for lifecycle monitoring
public class MvcLifecycleModule : IHttpModule
{
    public void Init(HttpApplication context)
    {
        context.BeginRequest += (sender, e) => {
            HttpContext.Current.Items["RequestStartTime"] = DateTime.UtcNow;
            LogLifecycleEvent("BeginRequest", "Request initiated");
        };
        
        context.AuthenticateRequest += (sender, e) => {
            LogLifecycleEvent("AuthenticateRequest", "Authentication phase");
        };
        
        context.AuthorizeRequest += (sender, e) => {
            LogLifecycleEvent("AuthorizeRequest", "Authorization phase");
        };
        
        context.ResolveRequestCache += (sender, e) => {
            LogLifecycleEvent("ResolveRequestCache", "Cache resolution phase");
        };
        
        context.MapRequestHandler += (sender, e) => {
            LogLifecycleEvent("MapRequestHandler", "Handler mapping phase");
        };
        
        context.AcquireRequestState += (sender, e) => {
            LogLifecycleEvent("AcquireRequestState", "Session state acquisition");
        };
        
        context.PreExecuteRequestHandler += (sender, e) => {
            LogLifecycleEvent("PreExecuteRequestHandler", "Pre-execution phase");
        };
        
        context.PostExecuteRequestHandler += (sender, e) => {
            LogLifecycleEvent("PostExecuteRequestHandler", "Post-execution phase");
        };
        
        context.EndRequest += (sender, e) => {
            var startTime = (DateTime)HttpContext.Current.Items["RequestStartTime"];
            var duration = DateTime.UtcNow - startTime;
            LogLifecycleEvent("EndRequest", $"Request completed in {duration.TotalMilliseconds}ms");
        };
    }
    
    private void LogLifecycleEvent(string phase, string description)
    {
        var context = HttpContext.Current;
        var timestamp = DateTime.UtcNow;
        var url = context.Request.Url.ToString();
        
        // Advanced logging with performance metrics
        System.Diagnostics.Debug.WriteLine(
            $"[{timestamp:HH:mm:ss.fff}] {phase}: {description} | URL: {url} | " +
            $"Memory: {GC.GetTotalMemory(false) / 1024}KB"
        );
    }
    
    public void Dispose() { }
}

// Advanced MVC lifecycle interceptor
public class AdvancedControllerFactory : DefaultControllerFactory
{
    protected override IController GetControllerInstance(RequestContext requestContext, Type controllerType)
    {
        if (controllerType == null) return null;
        
        // Custom controller instantiation with dependency injection
        var controller = base.GetControllerInstance(requestContext, controllerType);
        
        // Inject lifecycle monitoring
        if (controller is Controller mvcController)
        {
            mvcController.ActionExecuting += OnActionExecuting;
            mvcController.ActionExecuted += OnActionExecuted;
            mvcController.ResultExecuting += OnResultExecuting;
            mvcController.ResultExecuted += OnResultExecuted;
        }
        
        return controller;
    }
    
    private void OnActionExecuting(object sender, ActionExecutingContext e)
    {
        e.HttpContext.Items["ActionStartTime"] = DateTime.UtcNow;
        LogControllerEvent("ActionExecuting", e.ActionDescriptor.ActionName, e.ActionDescriptor.ControllerDescriptor.ControllerName);
    }
    
    private void OnActionExecuted(object sender, ActionExecutedContext e)
    {
        var startTime = (DateTime)e.HttpContext.Items["ActionStartTime"];
        var duration = DateTime.UtcNow - startTime;
        LogControllerEvent("ActionExecuted", e.ActionDescriptor.ActionName, 
            e.ActionDescriptor.ControllerDescriptor.ControllerName, duration);
    }
    
    private void OnResultExecuting(object sender, ResultExecutingContext e)
    {
        e.HttpContext.Items["ResultStartTime"] = DateTime.UtcNow;
        LogControllerEvent("ResultExecuting", e.Result.GetType().Name, "");
    }
    
    private void OnResultExecuted(object sender, ResultExecutedContext e)
    {
        var startTime = (DateTime)e.HttpContext.Items["ResultStartTime"];
        var duration = DateTime.UtcNow - startTime;
        LogControllerEvent("ResultExecuted", e.Result.GetType().Name, "", duration);
    }
    
    private void LogControllerEvent(string phase, string action, string controller, TimeSpan? duration = null)
    {
        var durationText = duration.HasValue ? $" ({duration.Value.TotalMilliseconds}ms)" : "";
        System.Diagnostics.Debug.WriteLine(
            $"[MVC] {phase}: {controller}.{action}{durationText}"
        );
    }
}
```

#### Advanced Routing and URL Generation

```csharp
// Custom route constraint for advanced routing scenarios
public class ApiVersionConstraint : IRouteConstraint
{
    private readonly string _version;
    
    public ApiVersionConstraint(string version)
    {
        _version = version;
    }
    
    public bool Match(HttpContextBase httpContext, Route route, string parameterName, 
        RouteValueDictionary values, RouteDirection routeDirection)
    {
        if (routeDirection == RouteDirection.UrlGeneration)
            return true;
            
        // Check version in header, query string, or URL segment
        var requestedVersion = httpContext.Request.Headers["API-Version"] ??
                              httpContext.Request.QueryString["version"] ??
                              values["version"]?.ToString();
                              
        return string.Equals(requestedVersion, _version, StringComparison.OrdinalIgnoreCase);
    }
}

// Advanced route configuration
public class AdvancedRouteConfig
{
    public static void RegisterRoutes(RouteCollection routes)
    {
        routes.IgnoreRoute("{resource}.axd/{*pathInfo}");
        
        // API versioning routes
        routes.MapRoute(
            name: "ApiV1",
            url: "api/v1/{controller}/{action}/{id}",
            defaults: new { id = UrlParameter.Optional },
            constraints: new { version = new ApiVersionConstraint("1.0") },
            namespaces: new[] { "MyApp.Controllers.V1" }
        );
        
        routes.MapRoute(
            name: "ApiV2",
            url: "api/v2/{controller}/{action}/{id}",
            defaults: new { id = UrlParameter.Optional },
            constraints: new { version = new ApiVersionConstraint("2.0") },
            namespaces: new[] { "MyApp.Controllers.V2" }
        );
        
        // Localization routes
        routes.MapRoute(
            name: "Localized",
            url: "{culture}/{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional },
            constraints: new { culture = @"^[a-z]{2}(-[A-Z]{2})?$" }
        );
        
        // SEO-friendly routes with custom constraints
        routes.MapRoute(
            name: "ProductDetails",
            url: "products/{category}/{productSlug}-{id}",
            defaults: new { controller = "Product", action = "Details" },
            constraints: new { 
                id = @"\d+",
                category = new CategoryConstraint(),
                productSlug = @"^[a-z0-9\-]+$"
            }
        );
        
        // Default route
        routes.MapRoute(
            name: "Default",
            url: "{controller}/{action}/{id}",
            defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }
        );
    }
}

public class CategoryConstraint : IRouteConstraint
{
    private static readonly HashSet<string> ValidCategories = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
    {
        "electronics", "clothing", "books", "home-garden", "sports"
    };
    
    public bool Match(HttpContextBase httpContext, Route route, string parameterName, 
        RouteValueDictionary values, RouteDirection routeDirection)
    {
        if (values.TryGetValue(parameterName, out var value))
        {
            return ValidCategories.Contains(value?.ToString() ?? "");
        }
        return false;
    }
}
```

---

## Q147 — MVC Advantages over Web Forms

### Architectural Comparison and Migration Strategies

#### Comprehensive Feature Comparison Matrix

| Feature | ASP.NET Web Forms | ASP.NET MVC | Analysis |
|---------|------------------|-------------|----------|
| **Architecture** | Page-centric, event-driven | Pattern-based (MVC), stateless | MVC provides better separation of concerns |
| **State Management** | ViewState, server controls | Stateless, explicit state management | MVC reduces bandwidth, improves scalability |
| **URL Structure** | File-based (.aspx) | Route-based, RESTful | MVC enables SEO-friendly URLs |
| **Testing** | Difficult to unit test | Highly testable | MVC facilitates TDD/BDD approaches |
| **Control** | Abstracted HTML generation | Full HTML control | MVC provides precise markup control |
| **Performance** | ViewState overhead | Lightweight, no ViewState | MVC generally performs better |
| **Learning Curve** | Easier for desktop developers | Steeper, requires web knowledge | MVC requires understanding of HTTP/HTML |

#### Advanced Migration Framework

```csharp
// Web Forms to MVC migration helper
public class WebFormsMigrationHelper
{
    public class LegacyPageAdapter : Controller
    {
        public ActionResult RenderLegacyPage(string pagePath)
        {
            // Adapter pattern for gradual migration
            var legacyPage = BuildManager.CreateInstanceFromVirtualPath(
                $"~/Legacy/{pagePath}.aspx", typeof(Page)) as Page;
                
            if (legacyPage == null)
                return HttpNotFound();
            
            // Capture legacy page output
            using (var stringWriter = new StringWriter())
            using (var htmlWriter = new HtmlTextWriter(stringWriter))
            {
                // Simulate page lifecycle
                legacyPage.ProcessRequest(HttpContext.ApplicationInstance.Context);
                return Content(stringWriter.ToString(), "text/html");
            }
        }
    }
    
    // ViewState to TempData migration
    public static class ViewStateToTempDataMigrator
    {
        public static void MigrateViewState(Controller controller, string viewStateData)
        {
            if (string.IsNullOrEmpty(viewStateData)) return;
            
            try
            {
                // Deserialize ViewState (simplified)
                var viewState = DeserializeViewState(viewStateData);
                
                // Convert to TempData
                foreach (var kvp in viewState)
                {
                    controller.TempData[$"Migrated_{kvp.Key}"] = kvp.Value;
                }
            }
            catch (Exception ex)
            {
                // Log migration issues
                System.Diagnostics.Debug.WriteLine($"ViewState migration failed: {ex.Message}");
            }
        }
        
        private static Dictionary<string, object> DeserializeViewState(string viewStateData)
        {
            // Simplified ViewState deserialization
            // In real implementation, would use LosFormatter or similar
            return new Dictionary<string, object>();
        }
    }
}

// Advanced MVC controller with Web Forms compatibility
public class HybridController : Controller
{
    // Support for Web Forms-style postback handling
    public ActionResult PostBack(string eventTarget, string eventArgument)
    {
        // Handle legacy postback events
        var handler = GetPostBackHandler(eventTarget);
        if (handler != null)
        {
            var result = handler.HandlePostBack(eventArgument);
            return Json(result);
        }
        
        return Json(new { success = false, message = "Handler not found" });
    }
    
    private IPostBackHandler GetPostBackHandler(string eventTarget)
    {
        // Factory pattern for postback handlers
        switch (eventTarget)
        {
            case "btnSubmit":
                return new SubmitButtonHandler();
            case "gridView":
                return new GridViewHandler();
            default:
                return null;
        }
    }
    
    // Support for Web Forms-style validation
    protected bool ValidatePage()
    {
        var validationResults = new List<ValidationResult>();
        var context = new ValidationContext(this);
        
        return Validator.TryValidateObject(this, context, validationResults, true);
    }
}

public interface IPostBackHandler
{
    object HandlePostBack(string eventArgument);
}

public class SubmitButtonHandler : IPostBackHandler
{
    public object HandlePostBack(string eventArgument)
    {
        // Handle submit button postback
        return new { success = true, message = "Form submitted successfully" };
    }
}
```

---

## Q148 — Controller Action Return Types

### Comprehensive Action Result Architecture

#### Advanced Action Result Implementations

```csharp
// Custom action results for specialized scenarios
public class JsonNetResult : ActionResult
{
    public object Data { get; set; }
    public JsonSerializerSettings SerializerSettings { get; set; }
    public Encoding ContentEncoding { get; set; }
    public string ContentType { get; set; }
    
    public JsonNetResult(object data, JsonSerializerSettings serializerSettings = null)
    {
        Data = data;
        SerializerSettings = serializerSettings ?? new JsonSerializerSettings
        {
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            DateFormatHandling = DateFormatHandling.IsoDateFormat,
            NullValueHandling = NullValueHandling.Ignore
        };
        ContentType = "application/json";
    }
    
    public override void ExecuteResult(ControllerContext context)
    {
        if (context == null)
            throw new ArgumentNullException(nameof(context));
            
        var response = context.HttpContext.Response;
        response.ContentType = ContentType;
        
        if (ContentEncoding != null)
            response.ContentEncoding = ContentEncoding;
            
        if (Data != null)
        {
            var json = JsonConvert.SerializeObject(Data, SerializerSettings);
            response.Write(json);
        }
    }
}

// Advanced file result with streaming support
public class StreamingFileResult : ActionResult
{
    private readonly Stream _stream;
    private readonly string _contentType;
    private readonly string _fileName;
    private readonly bool _enableRangeProcessing;
    
    public StreamingFileResult(Stream stream, string contentType, string fileName = null, bool enableRangeProcessing = true)
    {
        _stream = stream ?? throw new ArgumentNullException(nameof(stream));
        _contentType = contentType;
        _fileName = fileName;
        _enableRangeProcessing = enableRangeProcessing;
    }
    
    public override void ExecuteResult(ControllerContext context)
    {
        var response = context.HttpContext.Response;
        var request = context.HttpContext.Request;
        
        response.ContentType = _contentType;
        
        if (!string.IsNullOrEmpty(_fileName))
        {
            response.AddHeader("Content-Disposition", $"attachment; filename=\"{_fileName}\"");
        }
        
        if (_enableRangeProcessing && !string.IsNullOrEmpty(request.Headers["Range"]))
        {
            ProcessRangeRequest(request, response);
        }
        else
        {
            response.AddHeader("Content-Length", _stream.Length.ToString());
            _stream.CopyTo(response.OutputStream);
        }
    }
    
    private void ProcessRangeRequest(HttpRequestBase request, HttpResponseBase response)
    {
        var rangeHeader = request.Headers["Range"];
        var ranges = ParseRangeHeader(rangeHeader, _stream.Length);
        
        if (ranges.Count == 1)
        {
            var range = ranges[0];
            response.StatusCode = 206; // Partial Content
            response.AddHeader("Content-Range", $"bytes {range.Start}-{range.End}/{_stream.Length}");
            response.AddHeader("Content-Length", (range.End - range.Start + 1).ToString());
            
            _stream.Seek(range.Start, SeekOrigin.Begin);
            var buffer = new byte[8192];
            var remaining = range.End - range.Start + 1;
            
            while (remaining > 0)
            {
                var bytesToRead = (int)Math.Min(buffer.Length, remaining);
                var bytesRead = _stream.Read(buffer, 0, bytesToRead);
                if (bytesRead == 0) break;
                
                response.OutputStream.Write(buffer, 0, bytesRead);
                remaining -= bytesRead;
            }
        }
        else
        {
            // Multiple ranges - would need multipart response
            response.StatusCode = 416; // Range Not Satisfiable
        }
    }
    
    private List<(long Start, long End)> ParseRangeHeader(string rangeHeader, long contentLength)
    {
        var ranges = new List<(long Start, long End)>();
        
        if (rangeHeader.StartsWith("bytes="))
        {
            var rangeSpecs = rangeHeader.Substring(6).Split(',');
            
            foreach (var rangeSpec in rangeSpecs)
            {
                var parts = rangeSpec.Trim().Split('-');
                if (parts.Length == 2)
                {
                    long start = 0, end = contentLength - 1;
                    
                    if (!string.IsNullOrEmpty(parts[0]))
                        start = long.Parse(parts[0]);
                        
                    if (!string.IsNullOrEmpty(parts[1]))
                        end = long.Parse(parts[1]);
                    else if (string.IsNullOrEmpty(parts[0]))
                        start = contentLength - long.Parse(parts[1]);
                        
                    ranges.Add((start, Math.Min(end, contentLength - 1)));
                }
            }
        }
        
        return ranges;
    }
}

// Advanced controller with comprehensive action result usage
public class AdvancedController : Controller
{
    // Standard action results with advanced patterns
    public ActionResult Index()
    {
        var model = GetDashboardData();
        
        // Content negotiation based on Accept header
        var acceptHeader = Request.Headers["Accept"];
        
        if (acceptHeader?.Contains("application/json") == true)
        {
            return new JsonNetResult(model);
        }
        else if (acceptHeader?.Contains("application/xml") == true)
        {
            return new XmlResult(model);
        }
        
        return View(model);
    }
    
    // Advanced file download with progress tracking
    public ActionResult DownloadFile(int fileId)
    {
        var fileInfo = GetFileInfo(fileId);
        if (fileInfo == null)
            return HttpNotFound();
            
        var stream = GetFileStream(fileId);
        return new StreamingFileResult(stream, fileInfo.ContentType, fileInfo.FileName);
    }
    
    // Conditional action result based on business logic
    public ActionResult ProcessOrder(int orderId)
    {
        var order = GetOrder(orderId);
        if (order == null)
            return HttpNotFound();
            
        var result = ProcessOrderLogic(order);
        
        switch (result.Status)
        {
            case OrderStatus.Completed:
                return RedirectToAction("OrderConfirmation", new { id = orderId });
                
            case OrderStatus.PaymentRequired:
                return RedirectToAction("Payment", "Billing", new { orderId });
                
            case OrderStatus.ValidationFailed:
                ModelState.AddModelError("", result.ErrorMessage);
                return View("OrderForm", order);
                
            case OrderStatus.InsufficientInventory:
                return new HttpStatusCodeResult(409, "Insufficient inventory");
                
            default:
                return new HttpStatusCodeResult(500, "Unexpected error occurred");
        }
    }
    
    // Async action with custom result
    public async Task<ActionResult> GenerateReport(ReportParameters parameters)
    {
        var reportData = await GenerateReportAsync(parameters);
        
        if (parameters.Format == "pdf")
        {
            var pdfStream = await GeneratePdfAsync(reportData);
            return new StreamingFileResult(pdfStream, "application/pdf", $"report_{DateTime.Now:yyyyMMdd}.pdf");
        }
        else if (parameters.Format == "excel")
        {
            var excelStream = await GenerateExcelAsync(reportData);
            return new StreamingFileResult(excelStream, "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", 
                $"report_{DateTime.Now:yyyyMMdd}.xlsx");
        }
        
        return new JsonNetResult(reportData);
    }
    
    // Helper methods (implementation details omitted for brevity)
    private object GetDashboardData() => new { Message = "Dashboard data" };
    private FileInfo GetFileInfo(int fileId) => new FileInfo { ContentType = "application/pdf", FileName = "test.pdf" };
    private Stream GetFileStream(int fileId) => new MemoryStream();
    private Order GetOrder(int orderId) => new Order { Id = orderId };
    private OrderResult ProcessOrderLogic(Order order) => new OrderResult { Status = OrderStatus.Completed };
    private async Task<object> GenerateReportAsync(ReportParameters parameters) => await Task.FromResult(new { Data = "Report data" });
    private async Task<Stream> GeneratePdfAsync(object reportData) => await Task.FromResult(new MemoryStream());
    private async Task<Stream> GenerateExcelAsync(object reportData) => await Task.FromResult(new MemoryStream());
}

// Supporting classes
public class XmlResult : ActionResult
{
    private readonly object _data;
    
    public XmlResult(object data)
    {
        _data = data;
    }
    
    public override void ExecuteResult(ControllerContext context)
    {
        var response = context.HttpContext.Response;
        response.ContentType = "application/xml";
        
        var serializer = new XmlSerializer(_data.GetType());
        serializer.Serialize(response.OutputStream, _data);
    }
}

public class FileInfo
{
    public string ContentType { get; set; }
    public string FileName { get; set; }
}

public class Order
{
    public int Id { get; set; }
}

public class OrderResult
{
    public OrderStatus Status { get; set; }
    public string ErrorMessage { get; set; }
}

public enum OrderStatus
{
    Completed,
    PaymentRequired,
    ValidationFailed,
    InsufficientInventory
}

public class ReportParameters
{
    public string Format { get; set; }
}
```

---

## Q149 — Filters and Filter Types in MVC

### Advanced Filter Pipeline Architecture

#### Comprehensive Filter Implementation

```csharp
// Advanced authorization filter with role-based and claim-based security
public class AdvancedAuthorizeAttribute : AuthorizeAttribute, IAuthorizationFilter
{
    public string Claims { get; set; }
    public string Resource { get; set; }
    public string Action { get; set; }
    
    public override void OnAuthorization(AuthorizationContext filterContext)
    {
        if (filterContext == null)
            throw new ArgumentNullException(nameof(filterContext));
            
        // Skip authorization for child actions
        if (filterContext.IsChildAction)
            return;
            
        // Check if action allows anonymous access
        if (filterContext.ActionDescriptor.IsDefined(typeof(AllowAnonymousAttribute), true) ||
            filterContext.ActionDescriptor.ControllerDescriptor.IsDefined(typeof(AllowAnonymousAttribute), true))
        {
            return;
        }
        
        // Perform authentication check
        if (!filterContext.HttpContext.User.Identity.IsAuthenticated)
        {
            HandleUnauthorizedRequest(filterContext);
            return;
        }
        
        // Advanced authorization logic
        if (!IsAuthorized(filterContext))
        {
            HandleUnauthorizedRequest(filterContext);
            return;
        }
        
        // Cache authorization result
        CacheAuthorizationResult(filterContext);
    }
    
    protected override bool AuthorizeCore(HttpContextBase httpContext)
    {
        if (!base.AuthorizeCore(httpContext))
            return false;
            
        // Claims-based authorization
        if (!string.IsNullOrEmpty(Claims))
        {
            var requiredClaims = Claims.Split(',').Select(c => c.Trim());
            var userClaims = GetUserClaims(httpContext.User);
            
            if (!requiredClaims.All(claim => userClaims.Contains(claim)))
                return false;
        }
        
        // Resource-based authorization
        if (!string.IsNullOrEmpty(Resource) && !string.IsNullOrEmpty(Action))
        {
            return CheckResourcePermission(httpContext.User, Resource, Action);
        }
        
        return true;
    }
    
    private IEnumerable<string> GetUserClaims(IPrincipal user)
    {
        if (user is ClaimsPrincipal claimsPrincipal)
        {
            return claimsPrincipal.Claims.Select(c => c.Type);
        }
        
        return Enumerable.Empty<string>();
    }
    
    private bool CheckResourcePermission(IPrincipal user, string resource, string action)
    {
        // Implement resource-based authorization logic
        // This could integrate with a policy engine or permission system
        return true; // Simplified for example
    }
    
    private void CacheAuthorizationResult(AuthorizationContext filterContext)
    {
        var cacheKey = $"auth_{filterContext.HttpContext.User.Identity.Name}_{filterContext.ActionDescriptor.ActionName}";
        HttpContext.Current.Cache.Insert(cacheKey, true, null, DateTime.Now.AddMinutes(5), TimeSpan.Zero);
    }
}

// Advanced action filter with performance monitoring and caching
public class PerformanceMonitoringAttribute : ActionFilterAttribute
{
    public bool EnableCaching { get; set; }
    public int CacheDurationMinutes { get; set; } = 5;
    public string[] VaryByParams { get; set; }
    
    public override void OnActionExecuting(ActionExecutingContext filterContext)
    {
        var stopwatch = Stopwatch.StartNew();
        filterContext.HttpContext.Items["ActionStopwatch"] = stopwatch;
        
        // Check cache if enabled
        if (EnableCaching)
        {
            var cacheKey = GenerateCacheKey(filterContext);
            var cachedResult = HttpContext.Current.Cache[cacheKey];
            
            if (cachedResult is ActionResult result)
            {
                filterContext.Result = result;
                return;
            }
        }
        
        // Log action start
        LogActionStart(filterContext);
        
        base.OnActionExecuting(filterContext);
    }
    
    public override void OnActionExecuted(ActionExecutedContext filterContext)
    {
        var stopwatch = (Stopwatch)filterContext.HttpContext.Items["ActionStopwatch"];
        stopwatch?.Stop();
        
        // Cache result if enabled and successful
        if (EnableCaching && filterContext.Exception == null && filterContext.Result != null)
        {
            var cacheKey = GenerateCacheKey(filterContext);
            HttpContext.Current.Cache.Insert(
                cacheKey, 
                filterContext.Result, 
                null, 
                DateTime.Now.AddMinutes(CacheDurationMinutes), 
                TimeSpan.Zero
            );
        }
        
        // Log performance metrics
        LogActionEnd(filterContext, stopwatch?.ElapsedMilliseconds ?? 0);
        
        base.OnActionExecuted(filterContext);
    }
    
    private string GenerateCacheKey(ControllerContext context)
    {
        var keyBuilder = new StringBuilder();
        keyBuilder.Append($"{context.RouteData.Values["controller"]}_{context.RouteData.Values["action"]}");
        
        if (VaryByParams != null)
        {
            foreach (var param in VaryByParams)
            {
                var value = context.HttpContext.Request.Params[param];
                keyBuilder.Append($"_{param}={value}");
            }
        }
        
        return keyBuilder.ToString();
    }
    
    private void LogActionStart(ActionExecutingContext context)
    {
        var actionName = $"{context.ActionDescriptor.ControllerDescriptor.ControllerName}.{context.ActionDescriptor.ActionName}";
        System.Diagnostics.Debug.WriteLine($"[PERF] Starting action: {actionName}");
    }
    
    private void LogActionEnd(ActionExecutedContext context, long elapsedMs)
    {
        var actionName = $"{context.ActionDescriptor.ControllerDescriptor.ControllerName}.{context.ActionDescriptor.ActionName}";
        var status = context.Exception == null ? "SUCCESS" : "ERROR";
        System.Diagnostics.Debug.WriteLine($"[PERF] Completed action: {actionName} in {elapsedMs}ms - {status}");
    }
}

// Advanced exception filter with detailed error handling
public class GlobalExceptionFilterAttribute : FilterAttribute, IExceptionFilter
{
    public void OnException(ExceptionContext filterContext)
    {
        if (filterContext == null || filterContext.ExceptionHandled)
            return;
            
        var exception = filterContext.Exception;
        var httpContext = filterContext.HttpContext;
        
        // Log the exception with context
        LogException(exception, filterContext);
        
        // Determine response based on exception type and request context
        var result = CreateErrorResponse(exception, filterContext);
        
        if (result != null)
        {
            filterContext.Result = result;
            filterContext.ExceptionHandled = true;
            
            // Clear response if already started
            if (!httpContext.Response.IsRequestBeingRedirected)
            {
                httpContext.Response.Clear();
                httpContext.Response.StatusCode = GetStatusCode(exception);
            }
        }
    }
    
    private ActionResult CreateErrorResponse(Exception exception, ExceptionContext context)
    {
        var isAjaxRequest = context.HttpContext.Request.IsAjaxRequest();
        var acceptsJson = context.HttpContext.Request.AcceptTypes?.Contains("application/json") == true;
        
        if (isAjaxRequest || acceptsJson)
        {
            return CreateJsonErrorResponse(exception, context);
        }
        else
        {
            return CreateViewErrorResponse(exception, context);
        }
    }
    
    private ActionResult CreateJsonErrorResponse(Exception exception, ExceptionContext context)
    {
        var errorModel = new
        {
            Error = true,
            Message = GetUserFriendlyMessage(exception),
            Details = context.HttpContext.IsDebuggingEnabled ? exception.ToString() : null,
            Timestamp = DateTime.UtcNow,
            RequestId = context.HttpContext.Items["RequestId"]?.ToString()
        };
        
        return new JsonResult
        {
            Data = errorModel,
            JsonRequestBehavior = JsonRequestBehavior.AllowGet
        };
    }
    
    private ActionResult CreateViewErrorResponse(Exception exception, ExceptionContext context)
    {
        var statusCode = GetStatusCode(exception);
        var viewName = GetErrorViewName(statusCode);
        
        var model = new ErrorViewModel
        {
            StatusCode = statusCode,
            Message = GetUserFriendlyMessage(exception),
            Details = context.HttpContext.IsDebuggingEnabled ? exception.ToString() : null,
            RequestId = context.HttpContext.Items["RequestId"]?.ToString()
        };
        
        return new ViewResult
        {
            ViewName = viewName,
            ViewData = new ViewDataDictionary(model)
        };
    }
    
    private int GetStatusCode(Exception exception)
    {
        switch (exception)
        {
            case ArgumentException _:
            case ValidationException _:
                return 400; // Bad Request
                
            case UnauthorizedAccessException _:
                return 401; // Unauthorized
                
            case SecurityException _:
                return 403; // Forbidden
                
            case FileNotFoundException _:
            case KeyNotFoundException _:
                return 404; // Not Found
                
            case NotSupportedException _:
                return 405; // Method Not Allowed
                
            case TimeoutException _:
                return 408; // Request Timeout
                
            default:
                return 500; // Internal Server Error
        }
    }
    
    private string GetErrorViewName(int statusCode)
    {
        return statusCode switch
        {
            404 => "NotFound",
            403 => "Forbidden",
            401 => "Unauthorized",
            _ => "Error"
        };
    }
    
    private string GetUserFriendlyMessage(Exception exception)
    {
        return exception switch
        {
            ValidationException _ => "The provided data is invalid.",
            UnauthorizedAccessException _ => "You are not authorized to perform this action.",
            FileNotFoundException _ => "The requested resource was not found.",
            TimeoutException _ => "The request timed out. Please try again.",
            _ => "An unexpected error occurred. Please try again later."
        };
    }
    
    private void LogException(Exception exception, ExceptionContext context)
    {
        var logEntry = new
        {
            Timestamp = DateTime.UtcNow,
            Exception = exception.ToString(),
            Controller = context.RouteData.Values["controller"],
            Action = context.RouteData.Values["action"],
            User = context.HttpContext.User?.Identity?.Name,
            UserAgent = context.HttpContext.Request.UserAgent,
            IPAddress = context.HttpContext.Request.UserHostAddress,
            Url = context.HttpContext.Request.Url?.ToString(),
            Referrer = context.HttpContext.Request.UrlReferrer?.ToString()
        };
        
        // Log to your preferred logging framework
        System.Diagnostics.Debug.WriteLine($"[ERROR] {JsonConvert.SerializeObject(logEntry, Formatting.Indented)}");
    }
}

// Supporting classes
public class ErrorViewModel
{
    public int StatusCode { get; set; }
    public string Message { get; set; }
    public string Details { get; set; }
    public string RequestId { get; set; }
}

public class ValidationException : Exception
{
    public ValidationException(string message) : base(message) { }
}
```

---

## Q150 — Authentication and Authorization in ASP.NET MVC

### Enterprise-Grade Security Implementation

#### Advanced Authentication System

```csharp
// Custom authentication provider with multiple authentication schemes
public class MultiSchemeAuthenticationModule : IHttpModule
{
    public void Init(HttpApplication context)
    {
        context.AuthenticateRequest += OnAuthenticateRequest;
        context.EndRequest += OnEndRequest;
    }
    
    private void OnAuthenticateRequest(object sender, EventArgs e)
    {
        var context = HttpContext.Current;
        var request = context.Request;
        
        // Try different authentication schemes in order of preference
        IPrincipal principal = null;
        
        // 1. JWT Token Authentication
        principal = AuthenticateJwtToken(request);
        
        // 2. API Key Authentication
        if (principal == null)
            principal = AuthenticateApiKey(request);
            
        // 3. Forms Authentication (fallback)
        if (principal == null)
            principal = AuthenticateFormsAuth(request);
            
        // 4. Windows Authentication
        if (principal == null)
            principal = AuthenticateWindows(request);
        
        if (principal != null)
        {
            context.User = principal;
            Thread.CurrentPrincipal = principal;
        }
    }
    
    private IPrincipal AuthenticateJwtToken(HttpRequest request)
    {
        var authHeader = request.Headers["Authorization"];
        if (string.IsNullOrEmpty(authHeader) || !authHeader.StartsWith("Bearer "))
            return null;
            
        var token = authHeader.Substring("Bearer ".Length);
        
        try
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var validationParameters = GetTokenValidationParameters();
            
            var principal = tokenHandler.ValidateToken(token, validationParameters, out var validatedToken);
            return principal;
        }
        catch (Exception ex)
        {
            System.Diagnostics.Debug.WriteLine($"JWT validation failed: {ex.Message}");
            return null;
        }
    }
    
    private IPrincipal AuthenticateApiKey(HttpRequest request)
    {
        var apiKey = request.Headers["X-API-Key"] ?? request.QueryString["apikey"];
        if (string.IsNullOrEmpty(apiKey))
            return null;
            
        var user = ValidateApiKey(apiKey);
        if (user != null)
        {
            var identity = new GenericIdentity(user.Username, "ApiKey");
            var roles = GetUserRoles(user.UserId);
            return new GenericPrincipal(identity, roles);
        }
        
        return null;
    }
    
    private IPrincipal AuthenticateFormsAuth(HttpRequest request)
    {
        var authCookie = request.Cookies[FormsAuthentication.FormsCookieName];
        if (authCookie?.Value != null)
        {
            try
            {
                var ticket = FormsAuthentication.Decrypt(authCookie.Value);
                if (ticket != null && !ticket.Expired)
                {
                    var identity = new FormsIdentity(ticket);
                    var roles = GetUserRoles(identity.Name);
                    return new GenericPrincipal(identity, roles);
                }
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Forms auth validation failed: {ex.Message}");
            }
        }
        
        return null;
    }
    
    private IPrincipal AuthenticateWindows(HttpRequest request)
    {
        if (request.IsAuthenticated && request.LogonUserIdentity != null)
        {
            return new WindowsPrincipal(request.LogonUserIdentity);
        }
        
        return null;
    }
    
    private TokenValidationParameters GetTokenValidationParameters()
    {
        return new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("your-secret-key")),
            ValidateIssuer = true,
            ValidIssuer = "your-issuer",
            ValidateAudience = true,
            ValidAudience = "your-audience",
            ValidateLifetime = true,
            ClockSkew = TimeSpan.Zero
        };
    }
    
    private ApiUser ValidateApiKey(string apiKey)
    {
        // Implement API key validation logic
        // This could query a database or cache
        return new ApiUser { UserId = 1, Username = "api-user" };
    }
    
    private string[] GetUserRoles(object userId)
    {
        // Implement role retrieval logic
        return new[] { "User", "ApiAccess" };
    }
    
    private void OnEndRequest(object sender, EventArgs e)
    {
        var context = HttpContext.Current;
        
        // Handle authentication challenges
        if (context.Response.StatusCode == 401)
        {
            HandleAuthenticationChallenge(context);
        }
    }
    
    private void HandleAuthenticationChallenge(HttpContext context)
    {
        var request = context.Request;
        var response = context.Response;
        
        // Determine appropriate challenge based on request type
        if (request.IsAjaxRequest() || request.AcceptTypes?.Contains("application/json") == true)
        {
            // JSON response for AJAX requests
            response.ContentType = "application/json";
            response.Write(JsonConvert.SerializeObject(new
            {
                error = "unauthorized",
                message = "Authentication required",
                loginUrl = FormsAuthentication.LoginUrl
            }));
        }
        else
        {
            // Redirect to login page for regular requests
            response.Redirect(FormsAuthentication.LoginUrl + "?returnUrl=" + 
                HttpUtility.UrlEncode(request.Url.ToString()));
        }
    }
    
    public void Dispose() { }
}

// Advanced authorization with policy-based security
public class PolicyBasedAuthorizeAttribute : AuthorizeAttribute
{
    public string Policy { get; set; }
    
    protected override bool AuthorizeCore(HttpContextBase httpContext)
    {
        if (!base.AuthorizeCore(httpContext))
            return false;
            
        if (!string.IsNullOrEmpty(Policy))
        {
            var authorizationService = DependencyResolver.Current.GetService<IAuthorizationService>();
            var user = httpContext.User;
            var resource = GetResource(httpContext);
            
            var result = authorizationService.AuthorizeAsync(user, resource, Policy).Result;
            return result.Succeeded;
        }
        
        return true;
    }
    
    private object GetResource(HttpContextBase httpContext)
    {
        // Extract resource information from route data or request
        var routeData = httpContext.Request.RequestContext.RouteData;
        return new
        {
            Controller = routeData.Values["controller"],
            Action = routeData.Values["action"],
            Id = routeData.Values["id"]
        };
    }
}

// Authorization service interface and implementation
public interface IAuthorizationService
{
    Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource, string policy);
}

public class AuthorizationService : IAuthorizationService
{
    private readonly Dictionary<string, IAuthorizationPolicy> _policies;
    
    public AuthorizationService()
    {
        _policies = new Dictionary<string, IAuthorizationPolicy>
        {
            ["CanEditUser"] = new CanEditUserPolicy(),
            ["CanViewReports"] = new CanViewReportsPolicy(),
            ["AdminOnly"] = new AdminOnlyPolicy()
        };
    }
    
    public async Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource, string policy)
    {
        if (_policies.TryGetValue(policy, out var policyHandler))
        {
            return await policyHandler.AuthorizeAsync(user, resource);
        }
        
        return AuthorizationResult.Failed("Policy not found");
    }
}

public interface IAuthorizationPolicy
{
    Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource);
}

public class CanEditUserPolicy : IAuthorizationPolicy
{
    public async Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource)
    {
        // Implement user editing authorization logic
        if (user.IsInRole("Admin") || user.IsInRole("UserManager"))
        {
            return AuthorizationResult.Succeeded();
        }
        
        // Check if user is editing their own profile
        if (resource is dynamic res && res.Id != null)
        {
            var userId = GetCurrentUserId(user);
            if (userId.ToString() == res.Id.ToString())
            {
                return AuthorizationResult.Succeeded();
            }
        }
        
        return AuthorizationResult.Failed("Insufficient permissions to edit user");
    }
    
    private int GetCurrentUserId(IPrincipal user)
    {
        // Extract user ID from claims or identity
        return 1; // Simplified
    }
}

public class CanViewReportsPolicy : IAuthorizationPolicy
{
    public async Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource)
    {
        if (user.IsInRole("Admin") || user.IsInRole("Manager") || user.IsInRole("Analyst"))
        {
            return AuthorizationResult.Succeeded();
        }
        
        return AuthorizationResult.Failed("Insufficient permissions to view reports");
    }
}

public class AdminOnlyPolicy : IAuthorizationPolicy
{
    public async Task<AuthorizationResult> AuthorizeAsync(IPrincipal user, object resource)
    {
        if (user.IsInRole("Admin"))
        {
            return AuthorizationResult.Succeeded();
        }
        
        return AuthorizationResult.Failed("Admin access required");
    }
}

public class AuthorizationResult
{
    public bool Succeeded { get; private set; }
    public string FailureReason { get; private set; }
    
    private AuthorizationResult(bool succeeded, string failureReason = null)
    {
        Succeeded = succeeded;
        FailureReason = failureReason;
    }
    
    public static AuthorizationResult Succeeded() => new AuthorizationResult(true);
    public static AuthorizationResult Failed(string reason) => new AuthorizationResult(false, reason);
}

// Supporting classes
public class ApiUser
{
    public int UserId { get; set; }
    public string Username { get; set; }
}
```

---

## Hands-on Labs
1) Build comprehensive MVC application with advanced routing, custom action results, and performance monitoring
2) Implement sophisticated filter pipeline with caching, security, and exception handling
3) Design enterprise authentication system supporting multiple schemes (JWT, API keys, Forms, Windows)
4) Create policy-based authorization framework with resource-specific permissions

## Advanced Scenarios
- Design microservices-compatible MVC architecture with distributed authentication
- Implement advanced caching strategies with dependency invalidation
- Build real-time MVC applications with SignalR integration
- Create multi-tenant MVC applications with tenant-specific routing and authorization

## Performance and Scalability Considerations
- MVC request pipeline optimization and bottleneck identification
- Advanced caching strategies for controllers, actions, and views
- Asynchronous action patterns for high-concurrency scenarios
- Memory management and garbage collection optimization in MVC applications

## Further Reading
- ASP.NET MVC internals and request processing pipeline
- Advanced authentication and authorization patterns in web applications
- Performance optimization techniques for high-traffic MVC applications
- Modern web application security best practices and threat mitigation
