# Q101–Q105 — LINQ and .NET Basics (Interview‑Ready Guide)
> Learning Guide
> - Audience: Beginners learning C#/.NET fundamentals and LINQ
> - Prerequisites: Basic C# syntax (methods, types), arrays/lists, Visual Studio or VS Code
> - Objectives:
>   - Understand lambda expressions and how LINQ queries work
>   - Choose First vs FirstOrDefault safely and know when to use Single variants
>   - Recognize assemblies, GAC, and core .NET runtime components
> - How to use: Skim TL;DR, run the examples in a small console app, then attempt Scenario Prompts


> Learning Guide
> - Audience: .NET developers preparing for interviews or structured revision
> - Prerequisites: C# basics (delegates, generics), LINQ fundamentals, .NET deployment basics
> - Objectives:
>   - Write and reason about lambdas and closures
>   - Choose the correct LINQ retrieval operator (First/Single variants)
>   - Explain .NET components, assemblies, and GAC with versioning
> - How to use: Skim TL;DR, study Key Facts, do Scenario Prompts, then code the Pseudocode



---

## Q101 — Lambda Expressions (C#)

### TL;DR
- Concise syntax for anonymous functions used with delegates, events, and LINQ.
- Drive predicates, selectors, and projections; enable closures; improve readability.

### Key Facts
- Syntax: `(args) => expression` or block body.
- Strongly typed: type inference via var and generic delegates (Func/Action/Predicate).
- Captures outer variables (closures). Beware of loop‑variable capture pitfalls.

### Example
```csharp
var evens = numbers.Where(n => n % 2 == 0).Select(n => n * n);
Func<int,int> square = x => x * x;
```

### Best Practices
- Keep lambdas small; extract methods when complex.
- Prefer `Func<T>`/`Action<T>` over custom delegates.
- Avoid capturing mutable locals that outlive the scope.

### Mini MCQ
Which is true?
- A) Lambdas are always dynamic typed
- B) Lambdas can close over outer variables
- C) Lambdas cannot be used with LINQ
Answer: B

---

## Q102 — First vs FirstOrDefault (LINQ)

### TL;DR
- `First` throws if sequence is empty; `FirstOrDefault` returns default(T).

### Key Facts
- Both have predicate overloads.
- Use `Single/SingleOrDefault` when exactly one item is expected.
- For async sources (EF Core), use `FirstAsync/FirstOrDefaultAsync`.

### Example
```csharp
var first = items.First(); // throws if empty
var maybe = items.FirstOrDefault(); // returns null/default if empty
```

### Pitfalls
- Null/default masking logic bugs; check for nulls.
- Using `First()` when emptiness is valid.

### Mini MCQ
What does `FirstOrDefault` return on an empty sequence of reference types?
- A) Throws
- B) default(T) i.e., null
- C) 0
Answer: B

---

## Q103 — .NET Framework Components

### TL;DR
CLR, CTS/CLS, JIT, BCL/FCL, Assemblies/Metadata, GC.

### Key Facts
- CLR provides memory management, type safety, exceptions, security.
- CTS/CLS standardize types/language interop.
- Assemblies are deployment/versioning units.

### Example (Introspection)
```csharp
var asm = typeof(string).Assembly;
Console.WriteLine(asm.FullName);
```

### Mini MCQ
Which component enforces type safety at runtime?
- A) JIT
- B) CLR
- C) BCL
Answer: B

---

## Q104 — Assemblies and Types

### TL;DR
Assemblies contain IL, metadata, and a manifest; types include private, shared (strong‑named), satellite, dynamic.

### Key Facts
- Strong‑named assemblies can reside in GAC.
- Manifest includes name, version, culture, public key.

### Example
```csharp
AssemblyName n = new("MyLib") { Version = new Version(1,0,0,0) };
```

### Mini MCQ
Where do shared strong‑named assemblies live?
- A) Bin folder
- B) GAC
- C) Temp
Answer: B

---

## Q105 — GAC (Global Assembly Cache)

### TL;DR
Machine‑wide store for strong‑named assemblies enabling side‑by‑side versioning.

### Key Facts
- Managed by installer tools; older `gacutil` for dev scenarios.
- Use strong naming for shared libraries only when necessary.

### Scenario Prompt
You need two apps to share the same strong‑named library with different versions. How does GAC help and what are binding redirects?

### Takeaways
- Prefer app‑local deployment unless shared strong‑naming is required.
- Understand binding policies and redirects for versioning.


---

## Scenario Prompts
- Implement a LINQ pipeline that safely returns an optional value; explain when to use First/Single variants and error handling.
- Design a plugin loader using Reflection that discovers types by attribute and instantiates them safely.
- Version a shared assembly used by multiple apps; outline GAC usage vs app‑local deployment and binding redirects.

## Quick Pseudocode Cheat‑Sheet
```pseudo
// FirstOrDefault vs First
if items is empty:
  use FirstOrDefault -> returns default/null
else:
  use First

// Reflection type activation
for each type in assembly:
  if type has Attribute(Plugin):
    instance = Activator.CreateInstance(type)

// GAC decision
if library must be shared across many apps AND strong‑named:
  consider GAC + binding policies
else:
  prefer app‑local deployment
```

---

## Hands‑on Labs
1) Implement LINQ queries with safe retrieval using FirstOrDefault and validate null handling.
2) Build a small Reflection-based plugin loader that discovers types via a custom attribute.
3) Create two console apps that consume different versions of a shared assembly; test binding redirects.

## Practice Checklist
- [ ] I can predict when First vs FirstOrDefault vs Single are appropriate
- [ ] I can explain closures and avoid common capture bugs
- [ ] I can describe assemblies, strong naming, and GAC trade‑offs

## Further Reading
- Microsoft Docs: LINQ, Delegates, Lambda Expressions
- .NET Assembly Loading and Binding Redirects

## Module Takeaways
- Choose safer LINQ operators when emptiness is expected
- Understand versioning/deployment units (assemblies) and GAC implications
